{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport BigNumber from 'bignumber.js';\nimport { currency } from '@components/Common/Ticker';\nexport default function useBCH() {\n  var DUST = 0.000005;\n  var SEND_BCH_ERRORS = {\n    INSUFICIENT_FUNDS: 0,\n    NETWORK_ERROR: 1,\n    INSUFFICIENT_PRIORITY: 66,\n    DOUBLE_SPENDING: 18,\n    MAX_UNCONFIRMED_TXS: 64\n  };\n\n  var getRestUrl = function getRestUrl() {\n    var apiIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var apiString = process.env.REACT_APP_NETWORK === \"mainnet\" ? process.env.REACT_APP_BCHA_APIS : process.env.REACT_APP_BCHA_APIS_TEST;\n    var apiArray = apiString.split(',');\n    return apiArray[apiIndex];\n  };\n\n  var getTxHistory = function getTxHistory(BCH, addresses) {\n    var txHistoryResponse;\n    return _regeneratorRuntime.async(function getTxHistory$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.prev = 0;\n            _context.next = 3;\n            return _regeneratorRuntime.awrap(BCH.Electrumx.transactions(addresses));\n\n          case 3:\n            txHistoryResponse = _context.sent;\n\n            if (!(txHistoryResponse.success && txHistoryResponse.transactions)) {\n              _context.next = 8;\n              break;\n            }\n\n            return _context.abrupt(\"return\", txHistoryResponse.transactions);\n\n          case 8:\n            throw new Error('Error in getTxHistory');\n\n          case 9:\n            _context.next = 16;\n            break;\n\n          case 11:\n            _context.prev = 11;\n            _context.t0 = _context[\"catch\"](0);\n            console.log(\"Error in BCH.Electrumx.transactions(addresses):\");\n            console.log(_context.t0);\n            return _context.abrupt(\"return\", _context.t0);\n\n          case 16:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, null, [[0, 11]], Promise);\n  };\n\n  var getUtxos = function getUtxos(BCH, addresses) {\n    var utxosResponse;\n    return _regeneratorRuntime.async(function getUtxos$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.prev = 0;\n            _context2.next = 3;\n            return _regeneratorRuntime.awrap(BCH.Electrumx.utxo(addresses));\n\n          case 3:\n            utxosResponse = _context2.sent;\n            return _context2.abrupt(\"return\", utxosResponse.utxos);\n\n          case 7:\n            _context2.prev = 7;\n            _context2.t0 = _context2[\"catch\"](0);\n            console.log(\"Error in BCH.Electrumx.utxo(addresses):\");\n            return _context2.abrupt(\"return\", _context2.t0);\n\n          case 11:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, null, null, [[0, 7]], Promise);\n  };\n\n  var getSlpBalancesAndUtxos = function getSlpBalancesAndUtxos(BCH, utxos) {\n    var hydratedUtxoDetails, hydratedUtxos, i, hydratedUtxosAtAddress, j, hydratedUtxo, nullUtxos, nonSlpUtxos, slpUtxos, tokensById, tokens;\n    return _regeneratorRuntime.async(function getSlpBalancesAndUtxos$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.prev = 0;\n            _context3.next = 3;\n            return _regeneratorRuntime.awrap(BCH.SLP.Utils.hydrateUtxos(utxos));\n\n          case 3:\n            hydratedUtxoDetails = _context3.sent;\n            _context3.next = 10;\n            break;\n\n          case 6:\n            _context3.prev = 6;\n            _context3.t0 = _context3[\"catch\"](0);\n            console.log(\"Error in BCH.SLP.Utils.hydrateUtxos(utxosResponse.utxos)\");\n            console.log(_context3.t0);\n\n          case 10:\n            hydratedUtxos = [];\n\n            for (i = 0; i < hydratedUtxoDetails.slpUtxos.length; i += 1) {\n              hydratedUtxosAtAddress = hydratedUtxoDetails.slpUtxos[i];\n\n              for (j = 0; j < hydratedUtxosAtAddress.utxos.length; j += 1) {\n                hydratedUtxo = hydratedUtxosAtAddress.utxos[j];\n                hydratedUtxo.address = hydratedUtxosAtAddress.address;\n                hydratedUtxos.push(hydratedUtxo);\n              }\n            }\n\n            nullUtxos = hydratedUtxos.filter(function (utxo) {\n              return utxo.isValid === null;\n            });\n\n            if (!(nullUtxos.length > 0)) {\n              _context3.next = 16;\n              break;\n            }\n\n            console.log(nullUtxos.length + \" null utxos found, ignoring results\");\n            throw new Error('Null utxos found, ignoring results');\n\n          case 16:\n            nonSlpUtxos = hydratedUtxos.filter(function (utxo) {\n              return utxo.isValid === false && utxo.satoshis !== 546 && !utxo.tokenName;\n            });\n            slpUtxos = hydratedUtxos.filter(function (utxo) {\n              return utxo.isValid;\n            });\n            tokensById = {};\n            slpUtxos.forEach(function (slpUtxo) {\n              var token = tokensById[slpUtxo.tokenId];\n\n              if (token) {\n                if (slpUtxo.tokenQty) {\n                  token.balance = token.balance.plus(new BigNumber(slpUtxo.tokenQty));\n                }\n\n                if (slpUtxo.utxoType && !token.hasBaton) {\n                  token.hasBaton = slpUtxo.utxoType === 'minting-baton';\n                }\n              } else {\n                token = {};\n                token.info = slpUtxo;\n                token.tokenId = slpUtxo.tokenId;\n\n                if (slpUtxo.tokenQty) {\n                  token.balance = new BigNumber(slpUtxo.tokenQty);\n                } else {\n                  token.balance = new BigNumber(0);\n                }\n\n                if (slpUtxo.utxoType) {\n                  token.hasBaton = slpUtxo.utxoType === 'minting-baton';\n                } else {\n                  token.hasBaton = false;\n                }\n\n                tokensById[slpUtxo.tokenId] = token;\n              }\n            });\n            tokens = Object.values(tokensById);\n            return _context3.abrupt(\"return\", {\n              tokens: tokens,\n              nonSlpUtxos: nonSlpUtxos,\n              slpUtxos: slpUtxos\n            });\n\n          case 22:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, null, null, [[0, 6]], Promise);\n  };\n\n  var calcFee = function calcFee(BCH, utxos) {\n    var p2pkhOutputNumber = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;\n    var satoshisPerByte = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : currency.defaultFee;\n    var byteCount = BCH.BitcoinCash.getByteCount({\n      P2PKH: utxos.length\n    }, {\n      P2PKH: p2pkhOutputNumber\n    });\n    var txFee = Math.ceil(satoshisPerByte * byteCount);\n    return txFee;\n  };\n\n  var sendToken = function sendToken(BCH, wallet, slpBalancesAndUtxos, _ref) {\n    var tokenId, amount, tokenReceiverAddress, largestBchUtxo, bchECPair, tokenUtxos, transactionBuilder, originalAmount, finalTokenAmountSent, tokenAmountBeingSentToAddress, tokenUtxosBeingSpent, i, slpSendObj, slpData, txFee, remainder, redeemScript, _loop, _i, tx, hex, txidStr, link;\n\n    return _regeneratorRuntime.async(function sendToken$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            tokenId = _ref.tokenId, amount = _ref.amount, tokenReceiverAddress = _ref.tokenReceiverAddress;\n\n            if (!(slpBalancesAndUtxos.nonSlpUtxos.length === 0)) {\n              _context4.next = 3;\n              break;\n            }\n\n            throw new Error(\"You need some \" + currency.ticker + \" to send \" + currency.tokenTicker);\n\n          case 3:\n            largestBchUtxo = slpBalancesAndUtxos.nonSlpUtxos.reduce(function (previous, current) {\n              return previous.satoshis > current.satoshis ? previous : current;\n            });\n            bchECPair = BCH.ECPair.fromWIF(largestBchUtxo.wif);\n            tokenUtxos = slpBalancesAndUtxos.slpUtxos.filter(function (utxo, index) {\n              if (utxo && utxo.tokenId === tokenId && utxo.utxoType === 'token') {\n                  return true;\n                }\n\n              return false;\n            });\n\n            if (!(tokenUtxos.length === 0)) {\n              _context4.next = 8;\n              break;\n            }\n\n            throw new Error('No token UTXOs for the specified token could be found.');\n\n          case 8:\n            if (process.env.REACT_APP_NETWORK === 'mainnet') {\n              transactionBuilder = new BCH.TransactionBuilder();\n            } else transactionBuilder = new BCH.TransactionBuilder('testnet');\n\n            originalAmount = largestBchUtxo.value;\n            transactionBuilder.addInput(largestBchUtxo.tx_hash, largestBchUtxo.tx_pos);\n            finalTokenAmountSent = new BigNumber(0);\n            tokenAmountBeingSentToAddress = new BigNumber(amount);\n            tokenUtxosBeingSpent = [];\n            i = 0;\n\n          case 15:\n            if (!(i < tokenUtxos.length)) {\n              _context4.next = 24;\n              break;\n            }\n\n            finalTokenAmountSent = finalTokenAmountSent.plus(new BigNumber(tokenUtxos[i].tokenQty));\n            transactionBuilder.addInput(tokenUtxos[i].tx_hash, tokenUtxos[i].tx_pos);\n            tokenUtxosBeingSpent.push(tokenUtxos[i]);\n\n            if (!tokenAmountBeingSentToAddress.lte(finalTokenAmountSent)) {\n              _context4.next = 21;\n              break;\n            }\n\n            return _context4.abrupt(\"break\", 24);\n\n          case 21:\n            i++;\n            _context4.next = 15;\n            break;\n\n          case 24:\n            slpSendObj = BCH.SLP.TokenType1.generateSendOpReturn(tokenUtxosBeingSpent, tokenAmountBeingSentToAddress.toString());\n            slpData = slpSendObj.script;\n            transactionBuilder.addOutput(slpData, 0);\n            transactionBuilder.addOutput(BCH.SLP.Address.toLegacyAddress(tokenReceiverAddress), 546);\n\n            if (slpSendObj.outputs > 1) {\n              transactionBuilder.addOutput(BCH.SLP.Address.toLegacyAddress(tokenUtxosBeingSpent[0].address), 546);\n            }\n\n            txFee = calcFee(BCH, tokenUtxosBeingSpent, 5, 1.1 * currency.defaultFee);\n            remainder = originalAmount - txFee - 546 * 2;\n\n            if (!(remainder < 1)) {\n              _context4.next = 33;\n              break;\n            }\n\n            throw new Error('Selected UTXO does not have enough satoshis');\n\n          case 33:\n            transactionBuilder.addOutput(BCH.Address.toLegacyAddress(largestBchUtxo.address), remainder);\n            transactionBuilder.sign(0, bchECPair, redeemScript, transactionBuilder.hashTypes.SIGHASH_ALL, originalAmount);\n\n            _loop = function _loop(_i) {\n              var thisUtxo = tokenUtxosBeingSpent[_i];\n              var accounts = [wallet.Path245, wallet.Path145];\n              var utxoEcPair = BCH.ECPair.fromWIF(accounts.filter(function (acc) {\n                return acc.cashAddress === thisUtxo.address;\n              }).pop().fundingWif);\n              transactionBuilder.sign(1 + _i, utxoEcPair, redeemScript, transactionBuilder.hashTypes.SIGHASH_ALL, thisUtxo.value);\n            };\n\n            for (_i = 0; _i < tokenUtxosBeingSpent.length; _i++) {\n              _loop(_i);\n            }\n\n            tx = transactionBuilder.build();\n            hex = tx.toHex();\n            _context4.next = 41;\n            return _regeneratorRuntime.awrap(BCH.RawTransactions.sendRawTransaction([hex]));\n\n          case 41:\n            txidStr = _context4.sent;\n\n            if (txidStr && txidStr[0]) {\n              console.log(currency.tokenTicker + \" txid\", txidStr[0]);\n            }\n\n            if (process.env.REACT_APP_NETWORK === \"mainnet\") {\n              link = currency.blockExplorerUrl + \"/tx/\" + txidStr;\n            } else {\n              link = currency.blockExplorerUrlTestnet + \"/tx/\" + txidStr;\n            }\n\n            return _context4.abrupt(\"return\", link);\n\n          case 45:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n\n  var sendBch = function sendBch(BCH, wallet, utxos, _ref2, callbackTxId) {\n    var addresses, values, encodedOpReturn, value, REMAINDER_ADDR, inputUtxos, _transactionBuilder, satoshisToSend, originalAmount, txFee, i, utxo, vout, txid, remainder, error, _i2, address, _i3, _utxo, tx, hex, txidStr, link;\n\n    return _regeneratorRuntime.async(function sendBch$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            addresses = _ref2.addresses, values = _ref2.values, encodedOpReturn = _ref2.encodedOpReturn;\n            _context5.prev = 1;\n\n            if (!(!values || values.length === 0)) {\n              _context5.next = 4;\n              break;\n            }\n\n            return _context5.abrupt(\"return\", null);\n\n          case 4:\n            value = values.reduce(function (previous, current) {\n              return new BigNumber(current).plus(previous);\n            }, new BigNumber(0));\n            REMAINDER_ADDR = wallet.Path145.cashAddress;\n            inputUtxos = [];\n            if (process.env.REACT_APP_NETWORK === \"mainnet\") _transactionBuilder = new BCH.TransactionBuilder();else _transactionBuilder = new BCH.TransactionBuilder('testnet');\n            satoshisToSend = BCH.BitcoinCash.toSatoshi(value.toFixed(8));\n            originalAmount = new BigNumber(0);\n            txFee = 0;\n            i = 0;\n\n          case 12:\n            if (!(i < utxos.length)) {\n              _context5.next = 25;\n              break;\n            }\n\n            utxo = utxos[i];\n            originalAmount = originalAmount.plus(utxo.satoshis);\n            vout = utxo.vout;\n            txid = utxo.txid;\n\n            _transactionBuilder.addInput(txid, vout);\n\n            inputUtxos.push(utxo);\n            txFee = encodedOpReturn ? calcFee(BCH, inputUtxos, addresses.length + 2) : calcFee(BCH, inputUtxos, addresses.length + 1);\n\n            if (!originalAmount.minus(satoshisToSend).minus(txFee).gte(0)) {\n              _context5.next = 22;\n              break;\n            }\n\n            return _context5.abrupt(\"break\", 25);\n\n          case 22:\n            i++;\n            _context5.next = 12;\n            break;\n\n          case 25:\n            remainder = Math.floor(originalAmount.minus(satoshisToSend).minus(txFee));\n\n            if (!(remainder < 0)) {\n              _context5.next = 30;\n              break;\n            }\n\n            error = new Error(\"Insufficient funds\");\n            error.code = SEND_BCH_ERRORS.INSUFICIENT_FUNDS;\n            throw error;\n\n          case 30:\n            if (encodedOpReturn) {\n              _transactionBuilder.addOutput(encodedOpReturn, 0);\n            }\n\n            for (_i2 = 0; _i2 < addresses.length; _i2++) {\n              address = addresses[_i2];\n\n              _transactionBuilder.addOutput(BCH.Address.toCashAddress(address), BCH.BitcoinCash.toSatoshi(Number(values[_i2]).toFixed(8)));\n            }\n\n            if (remainder >= BCH.BitcoinCash.toSatoshi(DUST)) {\n              _transactionBuilder.addOutput(REMAINDER_ADDR, remainder);\n            }\n\n            for (_i3 = 0; _i3 < inputUtxos.length; _i3++) {\n              _utxo = inputUtxos[_i3];\n\n              _transactionBuilder.sign(_i3, BCH.ECPair.fromWIF(_utxo.wif), undefined, _transactionBuilder.hashTypes.SIGHASH_ALL, _utxo.satoshis);\n            }\n\n            tx = _transactionBuilder.build();\n            hex = tx.toHex();\n            _context5.next = 38;\n            return _regeneratorRuntime.awrap(BCH.RawTransactions.sendRawTransaction([hex]));\n\n          case 38:\n            txidStr = _context5.sent;\n\n            if (txidStr && txidStr[0]) {\n              console.log(currency.ticker + \" txid\", txidStr[0]);\n            }\n\n            if (callbackTxId) {\n              callbackTxId(txidStr);\n            }\n\n            if (process.env.REACT_APP_NETWORK === \"mainnet\") {\n              link = currency.blockExplorerUrl + \"/tx/\" + txidStr;\n            } else {\n              link = currency.blockExplorerUrlTestnet + \"/tx/\" + txidStr;\n            }\n\n            return _context5.abrupt(\"return\", link);\n\n          case 45:\n            _context5.prev = 45;\n            _context5.t0 = _context5[\"catch\"](1);\n\n            if (_context5.t0.error === 'insufficient priority (code 66)') {\n              _context5.t0.code = SEND_BCH_ERRORS.INSUFFICIENT_PRIORITY;\n            } else if (_context5.t0.error === 'txn-mempool-conflict (code 18)') {\n              _context5.t0.code = SEND_BCH_ERRORS.DOUBLE_SPENDING;\n            } else if (_context5.t0.error === 'Network Error') {\n              _context5.t0.code = SEND_BCH_ERRORS.NETWORK_ERROR;\n            } else if (_context5.t0.error === 'too-long-mempool-chain, too many unconfirmed ancestors [limit: 25] (code 64)') {\n              _context5.t0.code = SEND_BCH_ERRORS.MAX_UNCONFIRMED_TXS;\n            }\n\n            console.log(\"error: \", _context5.t0);\n            throw _context5.t0;\n\n          case 50:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, null, null, [[1, 45]], Promise);\n  };\n\n  var getBCH = function getBCH() {\n    var apiIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var fromWindowObject = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    if (fromWindowObject && window.SlpWallet) {\n      var SlpWallet = new window.SlpWallet('', {\n        restURL: getRestUrl(apiIndex)\n      });\n      return SlpWallet.bchjs;\n    }\n  };\n\n  return {\n    getBCH: getBCH,\n    calcFee: calcFee,\n    getUtxos: getUtxos,\n    getSlpBalancesAndUtxos: getSlpBalancesAndUtxos,\n    getTxHistory: getTxHistory,\n    getRestUrl: getRestUrl,\n    sendBch: sendBch,\n    sendToken: sendToken\n  };\n}","map":{"version":3,"sources":["/Users/alcipir/Repos/bitcoin-abc/web/cashtab/mobile/hooks/useBCH.js"],"names":["BigNumber","currency","useBCH","DUST","SEND_BCH_ERRORS","INSUFICIENT_FUNDS","NETWORK_ERROR","INSUFFICIENT_PRIORITY","DOUBLE_SPENDING","MAX_UNCONFIRMED_TXS","getRestUrl","apiIndex","apiString","process","env","REACT_APP_NETWORK","REACT_APP_BCHA_APIS","REACT_APP_BCHA_APIS_TEST","apiArray","split","getTxHistory","BCH","addresses","Electrumx","transactions","txHistoryResponse","success","Error","console","log","getUtxos","utxo","utxosResponse","utxos","getSlpBalancesAndUtxos","SLP","Utils","hydrateUtxos","hydratedUtxoDetails","hydratedUtxos","i","slpUtxos","length","hydratedUtxosAtAddress","j","hydratedUtxo","address","push","nullUtxos","filter","isValid","nonSlpUtxos","satoshis","tokenName","tokensById","forEach","slpUtxo","token","tokenId","tokenQty","balance","plus","utxoType","hasBaton","info","tokens","Object","values","calcFee","p2pkhOutputNumber","satoshisPerByte","defaultFee","byteCount","BitcoinCash","getByteCount","P2PKH","txFee","Math","ceil","sendToken","wallet","slpBalancesAndUtxos","amount","tokenReceiverAddress","ticker","tokenTicker","largestBchUtxo","reduce","previous","current","bchECPair","ECPair","fromWIF","wif","tokenUtxos","index","transactionBuilder","TransactionBuilder","originalAmount","value","addInput","tx_hash","tx_pos","finalTokenAmountSent","tokenAmountBeingSentToAddress","tokenUtxosBeingSpent","lte","slpSendObj","TokenType1","generateSendOpReturn","toString","slpData","script","addOutput","Address","toLegacyAddress","outputs","remainder","sign","redeemScript","hashTypes","SIGHASH_ALL","thisUtxo","accounts","Path245","Path145","utxoEcPair","acc","cashAddress","pop","fundingWif","tx","build","hex","toHex","RawTransactions","sendRawTransaction","txidStr","link","blockExplorerUrl","blockExplorerUrlTestnet","sendBch","callbackTxId","encodedOpReturn","REMAINDER_ADDR","inputUtxos","satoshisToSend","toSatoshi","toFixed","vout","txid","minus","gte","floor","error","code","toCashAddress","Number","undefined","getBCH","fromWindowObject","window","SlpWallet","restURL","bchjs"],"mappings":"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","sourcesContent":["import BigNumber from 'bignumber.js';\nimport { currency } from '@components/Common/Ticker';\n\nexport default function useBCH() {\n    const DUST = 0.000005;\n    const SEND_BCH_ERRORS = {\n        INSUFICIENT_FUNDS: 0,\n        NETWORK_ERROR: 1,\n        INSUFFICIENT_PRIORITY: 66, // ~insufficient fee\n        DOUBLE_SPENDING: 18,\n        MAX_UNCONFIRMED_TXS: 64,\n    };\n\n    const getRestUrl = (apiIndex = 0) => {\n        const apiString =\n            process.env.REACT_APP_NETWORK === `mainnet`\n                ? process.env.REACT_APP_BCHA_APIS\n                : process.env.REACT_APP_BCHA_APIS_TEST;\n        const apiArray = apiString.split(',');\n        return apiArray[apiIndex];\n    };\n\n    const getTxHistory = async (BCH, addresses) => {\n        let txHistoryResponse;\n        try {\n            //console.log(`API Call: BCH.Electrumx.utxo(addresses)`);\n            //console.log(addresses);\n            txHistoryResponse = await BCH.Electrumx.transactions(addresses);\n            //console.log(`BCH.Electrumx.transactions(addresses) succeeded`);\n            //console.log(`txHistoryResponse`, txHistoryResponse);\n            if (txHistoryResponse.success && txHistoryResponse.transactions) {\n                return txHistoryResponse.transactions;\n            } else {\n                // eslint-disable-next-line no-throw-literal\n                throw new Error('Error in getTxHistory');\n            }\n        } catch (err) {\n            console.log(`Error in BCH.Electrumx.transactions(addresses):`);\n            console.log(err);\n            return err;\n        }\n    };\n\n    // Split out the BCH.Electrumx.utxo(addresses) call from the getSlpBalancesandUtxos function\n    // If utxo set has not changed, you do not need to hydrate the utxo set\n    // This drastically reduces calls to the API\n    const getUtxos = async (BCH, addresses) => {\n        let utxosResponse;\n        try {\n            //console.log(`API Call: BCH.Electrumx.utxo(addresses)`);\n            //console.log(addresses);\n            utxosResponse = await BCH.Electrumx.utxo(addresses);\n            //console.log(`BCH.Electrumx.utxo(addresses) succeeded`);\n            //console.log(`utxosResponse`, utxosResponse);\n            return utxosResponse.utxos;\n        } catch (err) {\n            console.log(`Error in BCH.Electrumx.utxo(addresses):`);\n            return err;\n        }\n    };\n\n    const getSlpBalancesAndUtxos = async (BCH, utxos) => {\n        let hydratedUtxoDetails;\n\n        try {\n            hydratedUtxoDetails = await BCH.SLP.Utils.hydrateUtxos(utxos);\n            //console.log(`hydratedUtxoDetails`, hydratedUtxoDetails);\n        } catch (err) {\n            console.log(\n                `Error in BCH.SLP.Utils.hydrateUtxos(utxosResponse.utxos)`,\n            );\n            console.log(err);\n        }\n        const hydratedUtxos = [];\n        for (let i = 0; i < hydratedUtxoDetails.slpUtxos.length; i += 1) {\n            const hydratedUtxosAtAddress = hydratedUtxoDetails.slpUtxos[i];\n            for (let j = 0; j < hydratedUtxosAtAddress.utxos.length; j += 1) {\n                const hydratedUtxo = hydratedUtxosAtAddress.utxos[j];\n                hydratedUtxo.address = hydratedUtxosAtAddress.address;\n                hydratedUtxos.push(hydratedUtxo);\n            }\n        }\n\n        //console.log(`hydratedUtxos`, hydratedUtxos);\n\n        // WARNING\n        // If you hit rate limits, your above utxos object will come back with `isValid` as null, but otherwise ok\n        // You need to throw an error before setting nonSlpUtxos and slpUtxos in this case\n        const nullUtxos = hydratedUtxos.filter(utxo => utxo.isValid === null);\n        //console.log(`nullUtxos`, nullUtxos);\n        if (nullUtxos.length > 0) {\n            console.log(\n                `${nullUtxos.length} null utxos found, ignoring results`,\n            );\n            throw new Error('Null utxos found, ignoring results');\n        }\n\n        // Prevent app from treating slpUtxos as nonSlpUtxos\n        // Must enforce === false as api will occasionally return utxo.isValid === null\n        // Do not classify utxos with 546 satoshis as nonSlpUtxos as a precaution\n        // Do not classify any utxos that include token information as nonSlpUtxos\n        const nonSlpUtxos = hydratedUtxos.filter(\n            utxo =>\n                utxo.isValid === false &&\n                utxo.satoshis !== 546 &&\n                !utxo.tokenName,\n        );\n        const slpUtxos = hydratedUtxos.filter(utxo => utxo.isValid);\n\n        let tokensById = {};\n\n        slpUtxos.forEach(slpUtxo => {\n            let token = tokensById[slpUtxo.tokenId];\n\n            if (token) {\n                // Minting baton does nto have a slpUtxo.tokenQty type\n\n                if (slpUtxo.tokenQty) {\n                    token.balance = token.balance.plus(\n                        new BigNumber(slpUtxo.tokenQty),\n                    );\n                }\n\n                //token.hasBaton = slpUtxo.transactionType === \"genesis\";\n                if (slpUtxo.utxoType && !token.hasBaton) {\n                    token.hasBaton = slpUtxo.utxoType === 'minting-baton';\n                }\n\n                // Examples of slpUtxo\n                /*\n                Genesis transaction:\n                {\n                address: \"bitcoincash:qrhzv5t79e2afc3rdutcu0d3q20gl7ul3ue58whah6\"\n                decimals: 9\n                height: 617564\n                isValid: true\n                satoshis: 546\n                tokenDocumentHash: \"\"\n                tokenDocumentUrl: \"developer.bitcoin.com\"\n                tokenId: \"6c41f244676ecfcbe3b4fabee2c72c2dadf8d74f8849afabc8a549157db69199\"\n                tokenName: \"PiticoLaunch\"\n                tokenTicker: \"PTCL\"\n                tokenType: 1\n                tx_hash: \"6c41f244676ecfcbe3b4fabee2c72c2dadf8d74f8849afabc8a549157db69199\"\n                tx_pos: 2\n                txid: \"6c41f244676ecfcbe3b4fabee2c72c2dadf8d74f8849afabc8a549157db69199\"\n                utxoType: \"minting-baton\"\n                value: 546\n                vout: 2\n                }\n\n                Send transaction:\n                {\n                address: \"bitcoincash:qrhzv5t79e2afc3rdutcu0d3q20gl7ul3ue58whah6\"\n                decimals: 9\n                height: 655115\n                isValid: true\n                satoshis: 546\n                tokenDocumentHash: \"\"\n                tokenDocumentUrl: \"developer.bitcoin.com\"\n                tokenId: \"6c41f244676ecfcbe3b4fabee2c72c2dadf8d74f8849afabc8a549157db69199\"\n                tokenName: \"PiticoLaunch\"\n                tokenQty: 1.123456789\n                tokenTicker: \"PTCL\"\n                tokenType: 1\n                transactionType: \"send\"\n                tx_hash: \"dea400f963bc9f51e010f88533010f8d1f82fc2bcc485ff8500c3a82b25abd9e\"\n                tx_pos: 1\n                txid: \"dea400f963bc9f51e010f88533010f8d1f82fc2bcc485ff8500c3a82b25abd9e\"\n                utxoType: \"token\"\n                value: 546\n                vout: 1\n                }\n                */\n            } else {\n                token = {};\n                token.info = slpUtxo;\n                token.tokenId = slpUtxo.tokenId;\n                if (slpUtxo.tokenQty) {\n                    token.balance = new BigNumber(slpUtxo.tokenQty);\n                } else {\n                    token.balance = new BigNumber(0);\n                }\n                if (slpUtxo.utxoType) {\n                    token.hasBaton = slpUtxo.utxoType === 'minting-baton';\n                } else {\n                    token.hasBaton = false;\n                }\n\n                tokensById[slpUtxo.tokenId] = token;\n            }\n        });\n\n        const tokens = Object.values(tokensById);\n        // console.log(`tokens`, tokens);\n        return {\n            tokens,\n            nonSlpUtxos,\n            slpUtxos,\n        };\n    };\n\n    const calcFee = (\n        BCH,\n        utxos,\n        p2pkhOutputNumber = 2,\n        satoshisPerByte = currency.defaultFee,\n    ) => {\n        const byteCount = BCH.BitcoinCash.getByteCount(\n            { P2PKH: utxos.length },\n            { P2PKH: p2pkhOutputNumber },\n        );\n        const txFee = Math.ceil(satoshisPerByte * byteCount);\n        return txFee;\n    };\n\n    const sendToken = async (\n        BCH,\n        wallet,\n        slpBalancesAndUtxos,\n        { tokenId, amount, tokenReceiverAddress },\n    ) => {\n        // Handle error of user having no BCH\n        if (slpBalancesAndUtxos.nonSlpUtxos.length === 0) {\n            throw new Error(\n                `You need some ${currency.ticker} to send ${currency.tokenTicker}`,\n            );\n        }\n        const largestBchUtxo = slpBalancesAndUtxos.nonSlpUtxos.reduce(\n            (previous, current) =>\n                previous.satoshis > current.satoshis ? previous : current,\n        );\n\n        const bchECPair = BCH.ECPair.fromWIF(largestBchUtxo.wif);\n        const tokenUtxos = slpBalancesAndUtxos.slpUtxos.filter(\n            (utxo, index) => {\n                if (\n                    utxo && // UTXO is associated with a token.\n                    utxo.tokenId === tokenId && // UTXO matches the token ID.\n                    utxo.utxoType === 'token' // UTXO is not a minting baton.\n                ) {\n                    return true;\n                }\n                return false;\n            },\n        );\n\n        if (tokenUtxos.length === 0) {\n            throw new Error(\n                'No token UTXOs for the specified token could be found.',\n            );\n        }\n\n        // BEGIN transaction construction.\n\n        // instance of transaction builder\n        let transactionBuilder;\n        if (process.env.REACT_APP_NETWORK === 'mainnet') {\n            transactionBuilder = new BCH.TransactionBuilder();\n        } else transactionBuilder = new BCH.TransactionBuilder('testnet');\n\n        const originalAmount = largestBchUtxo.value;\n        transactionBuilder.addInput(\n            largestBchUtxo.tx_hash,\n            largestBchUtxo.tx_pos,\n        );\n\n        let finalTokenAmountSent = new BigNumber(0);\n        let tokenAmountBeingSentToAddress = new BigNumber(amount);\n\n        let tokenUtxosBeingSpent = [];\n        for (let i = 0; i < tokenUtxos.length; i++) {\n            finalTokenAmountSent = finalTokenAmountSent.plus(\n                new BigNumber(tokenUtxos[i].tokenQty),\n            );\n            transactionBuilder.addInput(\n                tokenUtxos[i].tx_hash,\n                tokenUtxos[i].tx_pos,\n            );\n            tokenUtxosBeingSpent.push(tokenUtxos[i]);\n            if (tokenAmountBeingSentToAddress.lte(finalTokenAmountSent)) {\n                break;\n            }\n        }\n\n        const slpSendObj = BCH.SLP.TokenType1.generateSendOpReturn(\n            tokenUtxosBeingSpent,\n            tokenAmountBeingSentToAddress.toString(),\n        );\n\n        const slpData = slpSendObj.script;\n\n        // Add OP_RETURN as first output.\n        transactionBuilder.addOutput(slpData, 0);\n\n        // Send dust transaction representing tokens being sent.\n        transactionBuilder.addOutput(\n            BCH.SLP.Address.toLegacyAddress(tokenReceiverAddress),\n            546,\n        );\n\n        // Return any token change back to the sender.\n        if (slpSendObj.outputs > 1) {\n            transactionBuilder.addOutput(\n                BCH.SLP.Address.toLegacyAddress(\n                    tokenUtxosBeingSpent[0].address,\n                ),\n                546,\n            );\n        }\n\n        // get byte count to calculate fee. paying 1 sat\n        // Note: This may not be totally accurate. Just guessing on the byteCount size.\n        const txFee = calcFee(\n            BCH,\n            tokenUtxosBeingSpent,\n            5,\n            1.1 * currency.defaultFee,\n        );\n\n        // amount to send back to the sending address. It's the original amount - 1 sat/byte for tx size\n        const remainder = originalAmount - txFee - 546 * 2;\n        if (remainder < 1) {\n            throw new Error('Selected UTXO does not have enough satoshis');\n        }\n        // Last output: send the BCH change back to the wallet.\n        transactionBuilder.addOutput(\n            BCH.Address.toLegacyAddress(largestBchUtxo.address),\n            remainder,\n        );\n\n        // Sign the transaction with the private key for the BCH UTXO paying the fees.\n        let redeemScript;\n        transactionBuilder.sign(\n            0,\n            bchECPair,\n            redeemScript,\n            transactionBuilder.hashTypes.SIGHASH_ALL,\n            originalAmount,\n        );\n\n        // Sign each token UTXO being consumed.\n        for (let i = 0; i < tokenUtxosBeingSpent.length; i++) {\n            const thisUtxo = tokenUtxosBeingSpent[i];\n            const accounts = [wallet.Path245, wallet.Path145];\n            const utxoEcPair = BCH.ECPair.fromWIF(\n                accounts\n                    .filter(acc => acc.cashAddress === thisUtxo.address)\n                    .pop().fundingWif,\n            );\n\n            transactionBuilder.sign(\n                1 + i,\n                utxoEcPair,\n                redeemScript,\n                transactionBuilder.hashTypes.SIGHASH_ALL,\n                thisUtxo.value,\n            );\n        }\n\n        // build tx\n        const tx = transactionBuilder.build();\n\n        // output rawhex\n        const hex = tx.toHex();\n        // console.log(`Transaction raw hex: `, hex);\n\n        // END transaction construction.\n\n        const txidStr = await BCH.RawTransactions.sendRawTransaction([hex]);\n        if (txidStr && txidStr[0]) {\n            console.log(`${currency.tokenTicker} txid`, txidStr[0]);\n        }\n\n        let link;\n        if (process.env.REACT_APP_NETWORK === `mainnet`) {\n            link = `${currency.blockExplorerUrl}/tx/${txidStr}`;\n        } else {\n            link = `${currency.blockExplorerUrlTestnet}/tx/${txidStr}`;\n        }\n\n        //console.log(`link`, link);\n\n        return link;\n    };\n\n    const sendBch = async (\n        BCH,\n        wallet,\n        utxos,\n        { addresses, values, encodedOpReturn },\n        callbackTxId,\n    ) => {\n        // Note: callbackTxId is a callback function that accepts a txid as its only parameter\n\n        try {\n            if (!values || values.length === 0) {\n                return null;\n            }\n\n            const value = values.reduce(\n                (previous, current) => new BigNumber(current).plus(previous),\n                new BigNumber(0),\n            );\n            const REMAINDER_ADDR = wallet.Path145.cashAddress;\n            const inputUtxos = [];\n            let transactionBuilder;\n\n            // instance of transaction builder\n            if (process.env.REACT_APP_NETWORK === `mainnet`)\n                transactionBuilder = new BCH.TransactionBuilder();\n            else transactionBuilder = new BCH.TransactionBuilder('testnet');\n\n            const satoshisToSend = BCH.BitcoinCash.toSatoshi(value.toFixed(8));\n            let originalAmount = new BigNumber(0);\n            let txFee = 0;\n            for (let i = 0; i < utxos.length; i++) {\n                const utxo = utxos[i];\n                originalAmount = originalAmount.plus(utxo.satoshis);\n                const vout = utxo.vout;\n                const txid = utxo.txid;\n                // add input with txid and index of vout\n                transactionBuilder.addInput(txid, vout);\n\n                inputUtxos.push(utxo);\n                txFee = encodedOpReturn\n                    ? calcFee(BCH, inputUtxos, addresses.length + 2)\n                    : calcFee(BCH, inputUtxos, addresses.length + 1);\n\n                if (originalAmount.minus(satoshisToSend).minus(txFee).gte(0)) {\n                    break;\n                }\n            }\n\n            // amount to send back to the remainder address.\n            const remainder = Math.floor(\n                originalAmount.minus(satoshisToSend).minus(txFee),\n            );\n            if (remainder < 0) {\n                const error = new Error(`Insufficient funds`);\n                error.code = SEND_BCH_ERRORS.INSUFICIENT_FUNDS;\n                throw error;\n            }\n\n            if (encodedOpReturn) {\n                transactionBuilder.addOutput(encodedOpReturn, 0);\n            }\n\n            // add output w/ address and amount to send\n            for (let i = 0; i < addresses.length; i++) {\n                const address = addresses[i];\n                transactionBuilder.addOutput(\n                    BCH.Address.toCashAddress(address),\n                    BCH.BitcoinCash.toSatoshi(Number(values[i]).toFixed(8)),\n                );\n            }\n\n            if (remainder >= BCH.BitcoinCash.toSatoshi(DUST)) {\n                transactionBuilder.addOutput(REMAINDER_ADDR, remainder);\n            }\n\n            // Sign the transactions with the HD node.\n            for (let i = 0; i < inputUtxos.length; i++) {\n                const utxo = inputUtxos[i];\n                transactionBuilder.sign(\n                    i,\n                    BCH.ECPair.fromWIF(utxo.wif),\n                    undefined,\n                    transactionBuilder.hashTypes.SIGHASH_ALL,\n                    utxo.satoshis,\n                );\n            }\n\n            // build tx\n            const tx = transactionBuilder.build();\n            // output rawhex\n            const hex = tx.toHex();\n\n            // Broadcast transaction to the network\n            const txidStr = await BCH.RawTransactions.sendRawTransaction([hex]);\n\n            if (txidStr && txidStr[0]) {\n                console.log(`${currency.ticker} txid`, txidStr[0]);\n            }\n            let link;\n\n            if (callbackTxId) {\n                callbackTxId(txidStr);\n            }\n            if (process.env.REACT_APP_NETWORK === `mainnet`) {\n                link = `${currency.blockExplorerUrl}/tx/${txidStr}`;\n            } else {\n                link = `${currency.blockExplorerUrlTestnet}/tx/${txidStr}`;\n            }\n            //console.log(`link`, link);\n\n            return link;\n        } catch (err) {\n            if (err.error === 'insufficient priority (code 66)') {\n                err.code = SEND_BCH_ERRORS.INSUFFICIENT_PRIORITY;\n            } else if (err.error === 'txn-mempool-conflict (code 18)') {\n                err.code = SEND_BCH_ERRORS.DOUBLE_SPENDING;\n            } else if (err.error === 'Network Error') {\n                err.code = SEND_BCH_ERRORS.NETWORK_ERROR;\n            } else if (\n                err.error ===\n                'too-long-mempool-chain, too many unconfirmed ancestors [limit: 25] (code 64)'\n            ) {\n                err.code = SEND_BCH_ERRORS.MAX_UNCONFIRMED_TXS;\n            }\n            console.log(`error: `, err);\n            throw err;\n        }\n    };\n\n    const getBCH = (apiIndex = 0, fromWindowObject = true) => {\n        if (fromWindowObject && window.SlpWallet) {\n            const SlpWallet = new window.SlpWallet('', {\n                restURL: getRestUrl(apiIndex),\n            });\n            return SlpWallet.bchjs;\n        }\n    };\n\n    return {\n        getBCH,\n        calcFee,\n        getUtxos,\n        getSlpBalancesAndUtxos,\n        getTxHistory,\n        getRestUrl,\n        sendBch,\n        sendToken,\n    };\n}\n"]},"metadata":{},"sourceType":"module"}