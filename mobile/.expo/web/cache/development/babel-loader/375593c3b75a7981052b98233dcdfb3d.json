{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\n\nvar _this = this,\n    _jsxFileName = \"/Users/alcipir/Repos/bitcoin-abc/web/cashtab/mobile/hooks/useWallet.js\";\n\nimport { useState, useEffect } from 'react';\nimport Paragraph from 'antd/lib/typography/Paragraph';\nimport { notification } from 'antd';\nimport useAsyncTimeout from \"./useAsyncTimeout\";\nimport usePrevious from \"./usePrevious\";\nimport useBCH from \"./useBCH\";\nimport BigNumber from 'bignumber.js';\nimport localforage from 'localforage';\nimport { currency } from \"../components/Common/Ticker\";\nimport _ from 'lodash';\n\nvar useWallet = function useWallet() {\n  var _useState = useState(false),\n      _useState2 = _slicedToArray(_useState, 2),\n      wallet = _useState2[0],\n      setWallet = _useState2[1];\n\n  var _useState3 = useState(null),\n      _useState4 = _slicedToArray(_useState3, 2),\n      fiatPrice = _useState4[0],\n      setFiatPrice = _useState4[1];\n\n  var _useState5 = useState(null),\n      _useState6 = _slicedToArray(_useState5, 2),\n      ws = _useState6[0],\n      setWs = _useState6[1];\n\n  var _useState7 = useState(false),\n      _useState8 = _slicedToArray(_useState7, 2),\n      apiError = _useState8[0],\n      setApiError = _useState8[1];\n\n  var _useState9 = useState({\n    balances: {},\n    tokens: [],\n    slpBalancesAndUtxos: [],\n    txHistory: []\n  }),\n      _useState10 = _slicedToArray(_useState9, 2),\n      walletState = _useState10[0],\n      setWalletState = _useState10[1];\n\n  var _useBCH = useBCH(),\n      getBCH = _useBCH.getBCH,\n      getUtxos = _useBCH.getUtxos,\n      getSlpBalancesAndUtxos = _useBCH.getSlpBalancesAndUtxos,\n      getTxHistory = _useBCH.getTxHistory;\n\n  var _useState11 = useState(true),\n      _useState12 = _slicedToArray(_useState11, 2),\n      loading = _useState12[0],\n      setLoading = _useState12[1];\n\n  var _useState13 = useState(0),\n      _useState14 = _slicedToArray(_useState13, 2),\n      apiIndex = _useState14[0],\n      setApiIndex = _useState14[1];\n\n  var _useState15 = useState(getBCH(apiIndex)),\n      _useState16 = _slicedToArray(_useState15, 2),\n      BCH = _useState16[0],\n      setBCH = _useState16[1];\n\n  var _useState17 = useState(null),\n      _useState18 = _slicedToArray(_useState17, 2),\n      utxos = _useState18[0],\n      setUtxos = _useState18[1];\n\n  var balances = walletState.balances,\n      tokens = walletState.tokens,\n      slpBalancesAndUtxos = walletState.slpBalancesAndUtxos,\n      txHistory = walletState.txHistory;\n  var previousBalances = usePrevious(balances);\n  var previousTokens = usePrevious(tokens);\n  var previousWallet = usePrevious(wallet);\n  var previousUtxos = usePrevious(utxos);\n\n  var tryNextAPI = function tryNextAPI() {\n    var currentApiIndex = apiIndex;\n    var apiString = process.env.REACT_APP_BCHA_APIS;\n    var apiArray = apiString.split(',');\n    console.log(\"You have \" + apiArray.length + \" APIs to choose from\");\n    console.log(\"Current selection: \" + apiIndex);\n\n    if (apiArray.length === 0) {\n      console.log(\"There are no backup APIs, you are stuck with this error\");\n      return;\n    } else if (currentApiIndex < apiArray.length - 1) {\n      currentApiIndex += 1;\n      console.log(\"Incrementing API index from \" + apiIndex + \" to \" + currentApiIndex);\n    } else {\n      console.log(\"Retrying first API index\");\n      currentApiIndex = 0;\n    }\n\n    console.log(\"Setting Api Index to \" + currentApiIndex);\n    setApiIndex(currentApiIndex);\n    return setBCH(getBCH(currentApiIndex));\n  };\n\n  var normalizeSlpBalancesAndUtxos = function normalizeSlpBalancesAndUtxos(slpBalancesAndUtxos, wallet) {\n    var Accounts = [wallet.Path245, wallet.Path145];\n    slpBalancesAndUtxos.nonSlpUtxos.forEach(function (utxo) {\n      var derivatedAccount = Accounts.find(function (account) {\n        return account.cashAddress === utxo.address;\n      });\n      utxo.wif = derivatedAccount.fundingWif;\n    });\n    return slpBalancesAndUtxos;\n  };\n\n  var normalizeBalance = function normalizeBalance(slpBalancesAndUtxos) {\n    var totalBalanceInSatoshis = slpBalancesAndUtxos.nonSlpUtxos.reduce(function (previousBalance, utxo) {\n      return previousBalance + utxo.satoshis;\n    }, 0);\n    return {\n      totalBalanceInSatoshis: totalBalanceInSatoshis,\n      totalBalance: BCH.BitcoinCash.toBitcoinCash(totalBalanceInSatoshis)\n    };\n  };\n\n  var deriveAccount = function deriveAccount(_ref) {\n    var masterHDNode, path, node, cashAddress, slpAddress;\n    return _regeneratorRuntime.async(function deriveAccount$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            masterHDNode = _ref.masterHDNode, path = _ref.path;\n            node = BCH.HDNode.derivePath(masterHDNode, path);\n            cashAddress = BCH.HDNode.toCashAddress(node);\n            slpAddress = BCH.SLP.Address.toSLPAddress(cashAddress);\n            return _context.abrupt(\"return\", {\n              cashAddress: cashAddress,\n              slpAddress: slpAddress,\n              fundingWif: BCH.HDNode.toWIF(node),\n              fundingAddress: BCH.SLP.Address.toSLPAddress(cashAddress),\n              legacyAddress: BCH.SLP.Address.toLegacyAddress(cashAddress)\n            });\n\n          case 5:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n\n  var haveUtxosChanged = function haveUtxosChanged(utxos, previousUtxos) {\n    if (utxos === null) {\n      return true;\n    }\n\n    if (typeof previousUtxos === 'undefined' || typeof utxos === 'undefined') {\n      return true;\n    }\n\n    if (utxos && utxos.length === 0) {\n      return true;\n    }\n\n    var utxoArraysUnchanged = _.isEqual(utxos, previousUtxos);\n\n    if (utxoArraysUnchanged) {\n      return false;\n    } else {\n      return true;\n    }\n  };\n\n  var _update = function update(_ref2) {\n    var wallet, setWalletState, cashAddresses, _utxos, utxosHaveChanged, _slpBalancesAndUtxos, _txHistory, _tokens, newState;\n\n    return _regeneratorRuntime.async(function update$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            wallet = _ref2.wallet, setWalletState = _ref2.setWalletState;\n            _context2.prev = 1;\n\n            if (wallet) {\n              _context2.next = 4;\n              break;\n            }\n\n            return _context2.abrupt(\"return\");\n\n          case 4:\n            cashAddresses = [wallet.Path245.cashAddress, wallet.Path145.cashAddress];\n            _context2.next = 7;\n            return _regeneratorRuntime.awrap(getUtxos(BCH, cashAddresses));\n\n          case 7:\n            _utxos = _context2.sent;\n\n            if (!(!_utxos || _.isEmpty(_utxos) || _utxos.error || _utxos.length < 2)) {\n              _context2.next = 10;\n              break;\n            }\n\n            throw new Error('Error fetching utxos');\n\n          case 10:\n            setUtxos(_utxos);\n            utxosHaveChanged = haveUtxosChanged(_utxos, previousUtxos);\n\n            if (utxosHaveChanged) {\n              _context2.next = 15;\n              break;\n            }\n\n            setApiError(false);\n            return _context2.abrupt(\"return\");\n\n          case 15:\n            _context2.next = 17;\n            return _regeneratorRuntime.awrap(getSlpBalancesAndUtxos(BCH, _utxos));\n\n          case 17:\n            _slpBalancesAndUtxos = _context2.sent;\n            _context2.next = 20;\n            return _regeneratorRuntime.awrap(getTxHistory(BCH, cashAddresses));\n\n          case 20:\n            _txHistory = _context2.sent;\n            console.log(\"slpBalancesAndUtxos\", _slpBalancesAndUtxos);\n\n            if (!(typeof _slpBalancesAndUtxos === 'undefined')) {\n              _context2.next = 25;\n              break;\n            }\n\n            console.log(\"slpBalancesAndUtxos is undefined\");\n            throw new Error('slpBalancesAndUtxos is undefined');\n\n          case 25:\n            _tokens = _slpBalancesAndUtxos.tokens;\n            newState = {\n              balances: {},\n              tokens: [],\n              slpBalancesAndUtxos: []\n            };\n            newState.slpBalancesAndUtxos = normalizeSlpBalancesAndUtxos(_slpBalancesAndUtxos, wallet);\n            newState.balances = normalizeBalance(_slpBalancesAndUtxos);\n            newState.tokens = _tokens;\n            newState.txHistory = _txHistory;\n            setWalletState(newState);\n            setApiError(false);\n            _context2.next = 42;\n            break;\n\n          case 35:\n            _context2.prev = 35;\n            _context2.t0 = _context2[\"catch\"](1);\n            console.log(\"Error in update({wallet, setWalletState})\");\n            console.log(_context2.t0);\n            setApiError(true);\n            console.log(\"Trying next API...\");\n            tryNextAPI();\n\n          case 42:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, null, null, [[1, 35]], Promise);\n  };\n\n  var getWallet = function getWallet() {\n    var wallet, existingWallet;\n    return _regeneratorRuntime.async(function getWallet$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.prev = 0;\n            _context3.prev = 1;\n            _context3.next = 4;\n            return _regeneratorRuntime.awrap(localforage.getItem('wallet'));\n\n          case 4:\n            existingWallet = _context3.sent;\n\n            if (existingWallet) {\n              _context3.next = 16;\n              break;\n            }\n\n            console.log(\"no existing wallet, checking local storage\");\n            existingWallet = JSON.parse(window.localStorage.getItem('wallet'));\n            console.log(\"existingWallet from localStorage\", existingWallet);\n\n            if (!(existingWallet !== null)) {\n              _context3.next = 16;\n              break;\n            }\n\n            _context3.next = 12;\n            return _regeneratorRuntime.awrap(getWalletDetails(existingWallet));\n\n          case 12:\n            wallet = _context3.sent;\n            _context3.next = 15;\n            return _regeneratorRuntime.awrap(localforage.setItem('wallet', wallet));\n\n          case 15:\n            return _context3.abrupt(\"return\", wallet);\n\n          case 16:\n            _context3.next = 22;\n            break;\n\n          case 18:\n            _context3.prev = 18;\n            _context3.t0 = _context3[\"catch\"](1);\n            console.log(_context3.t0);\n            existingWallet = null;\n\n          case 22:\n            if (!(existingWallet === null || !existingWallet)) {\n              _context3.next = 30;\n              break;\n            }\n\n            _context3.next = 25;\n            return _regeneratorRuntime.awrap(getWalletDetails(existingWallet));\n\n          case 25:\n            wallet = _context3.sent;\n            _context3.next = 28;\n            return _regeneratorRuntime.awrap(localforage.setItem('wallet', wallet));\n\n          case 28:\n            _context3.next = 31;\n            break;\n\n          case 30:\n            wallet = existingWallet;\n\n          case 31:\n            _context3.next = 36;\n            break;\n\n          case 33:\n            _context3.prev = 33;\n            _context3.t1 = _context3[\"catch\"](0);\n            console.log(_context3.t1);\n\n          case 36:\n            return _context3.abrupt(\"return\", wallet);\n\n          case 37:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, null, null, [[0, 33], [1, 18]], Promise);\n  };\n\n  var getWalletDetails = function getWalletDetails(wallet) {\n    var NETWORK, mnemonic, rootSeedBuffer, masterHDNode, Path245, Path145, name;\n    return _regeneratorRuntime.async(function getWalletDetails$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            if (wallet) {\n              _context4.next = 2;\n              break;\n            }\n\n            return _context4.abrupt(\"return\", false);\n\n          case 2:\n            NETWORK = process.env.REACT_APP_NETWORK;\n            mnemonic = wallet.mnemonic;\n            _context4.next = 6;\n            return _regeneratorRuntime.awrap(BCH.Mnemonic.toSeed(mnemonic));\n\n          case 6:\n            rootSeedBuffer = _context4.sent;\n            if (NETWORK === \"mainnet\") masterHDNode = BCH.HDNode.fromSeed(rootSeedBuffer);else masterHDNode = BCH.HDNode.fromSeed(rootSeedBuffer, 'testnet');\n            _context4.next = 10;\n            return _regeneratorRuntime.awrap(deriveAccount({\n              masterHDNode: masterHDNode,\n              path: \"m/44'/245'/0'/0/0\"\n            }));\n\n          case 10:\n            Path245 = _context4.sent;\n            _context4.next = 13;\n            return _regeneratorRuntime.awrap(deriveAccount({\n              masterHDNode: masterHDNode,\n              path: \"m/44'/145'/0'/0/0\"\n            }));\n\n          case 13:\n            Path145 = _context4.sent;\n            name = Path145.cashAddress.slice(12, 17);\n\n            if (wallet && wallet.name) {\n              name = wallet.name;\n            }\n\n            return _context4.abrupt(\"return\", {\n              mnemonic: wallet.mnemonic,\n              name: name,\n              Path245: Path245,\n              Path145: Path145\n            });\n\n          case 17:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n\n  var getSavedWallets = function getSavedWallets(activeWallet) {\n    var savedWallets, i;\n    return _regeneratorRuntime.async(function getSavedWallets$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            _context5.prev = 0;\n            _context5.next = 3;\n            return _regeneratorRuntime.awrap(localforage.getItem('savedWallets'));\n\n          case 3:\n            savedWallets = _context5.sent;\n\n            if (savedWallets === null) {\n              savedWallets = [];\n            }\n\n            _context5.next = 12;\n            break;\n\n          case 7:\n            _context5.prev = 7;\n            _context5.t0 = _context5[\"catch\"](0);\n            console.log(\"Error in getSavedWallets\");\n            console.log(_context5.t0);\n            savedWallets = [];\n\n          case 12:\n            for (i = 0; i < savedWallets.length; i += 1) {\n              if (typeof activeWallet !== 'undefined' && activeWallet.name && savedWallets[i].name === activeWallet.name) {\n                savedWallets.splice(i, 1);\n              }\n            }\n\n            return _context5.abrupt(\"return\", savedWallets);\n\n          case 14:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, null, null, [[0, 7]], Promise);\n  };\n\n  var _activateWallet = function activateWallet(walletToActivate) {\n    var currentlyActiveWallet, savedWallets, walletInSavedWallets, i;\n    return _regeneratorRuntime.async(function activateWallet$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            _context6.prev = 0;\n            _context6.next = 3;\n            return _regeneratorRuntime.awrap(localforage.getItem('wallet'));\n\n          case 3:\n            currentlyActiveWallet = _context6.sent;\n            _context6.next = 10;\n            break;\n\n          case 6:\n            _context6.prev = 6;\n            _context6.t0 = _context6[\"catch\"](0);\n            console.log(\"Error in localforage.getItem(\\\"wallet\\\") in activateWallet()\");\n            return _context6.abrupt(\"return\", false);\n\n          case 10:\n            _context6.prev = 10;\n            _context6.next = 13;\n            return _regeneratorRuntime.awrap(localforage.getItem('savedWallets'));\n\n          case 13:\n            savedWallets = _context6.sent;\n            _context6.next = 20;\n            break;\n\n          case 16:\n            _context6.prev = 16;\n            _context6.t1 = _context6[\"catch\"](10);\n            console.log(\"Error in localforage.getItem(\\\"savedWallets\\\") in activateWallet()\");\n            return _context6.abrupt(\"return\", false);\n\n          case 20:\n            walletInSavedWallets = false;\n\n            for (i = 0; i < savedWallets.length; i += 1) {\n              if (savedWallets[i].name === currentlyActiveWallet.name) {\n                walletInSavedWallets = true;\n              }\n            }\n\n            if (walletInSavedWallets) {\n              _context6.next = 33;\n              break;\n            }\n\n            console.log(\"Wallet is not in saved Wallets, adding\");\n            savedWallets.push(currentlyActiveWallet);\n            _context6.prev = 25;\n            _context6.next = 28;\n            return _regeneratorRuntime.awrap(localforage.setItem('savedWallets', savedWallets));\n\n          case 28:\n            _context6.next = 33;\n            break;\n\n          case 30:\n            _context6.prev = 30;\n            _context6.t2 = _context6[\"catch\"](25);\n            console.log(\"Error in localforage.setItem(\\\"savedWallets\\\") in activateWallet()\");\n\n          case 33:\n            _context6.prev = 33;\n            _context6.next = 36;\n            return _regeneratorRuntime.awrap(localforage.setItem('wallet', walletToActivate));\n\n          case 36:\n            _context6.next = 42;\n            break;\n\n          case 38:\n            _context6.prev = 38;\n            _context6.t3 = _context6[\"catch\"](33);\n            console.log(\"Error in localforage.setItem(\\\"wallet\\\", walletToActivate) in activateWallet()\");\n            return _context6.abrupt(\"return\", false);\n\n          case 42:\n            return _context6.abrupt(\"return\", walletToActivate);\n\n          case 43:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, null, null, [[0, 6], [10, 16], [25, 30], [33, 38]], Promise);\n  };\n\n  var renameWallet = function renameWallet(oldName, newName) {\n    var savedWallets, i, _i;\n\n    return _regeneratorRuntime.async(function renameWallet$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            _context7.prev = 0;\n            _context7.next = 3;\n            return _regeneratorRuntime.awrap(localforage.getItem('savedWallets'));\n\n          case 3:\n            savedWallets = _context7.sent;\n            _context7.next = 11;\n            break;\n\n          case 6:\n            _context7.prev = 6;\n            _context7.t0 = _context7[\"catch\"](0);\n            console.log(\"Error in await localforage.getItem(\\\"savedWallets\\\") in renameWallet\");\n            console.log(_context7.t0);\n            return _context7.abrupt(\"return\", false);\n\n          case 11:\n            i = 0;\n\n          case 12:\n            if (!(i < savedWallets.length)) {\n              _context7.next = 18;\n              break;\n            }\n\n            if (!(savedWallets[i].name === newName)) {\n              _context7.next = 15;\n              break;\n            }\n\n            return _context7.abrupt(\"return\", false);\n\n          case 15:\n            i += 1;\n            _context7.next = 12;\n            break;\n\n          case 18:\n            for (_i = 0; _i < savedWallets.length; _i += 1) {\n              if (savedWallets[_i].name === oldName) {\n                savedWallets[_i].name = newName;\n              }\n            }\n\n            _context7.prev = 19;\n            _context7.next = 22;\n            return _regeneratorRuntime.awrap(localforage.setItem('savedWallets', savedWallets));\n\n          case 22:\n            _context7.next = 28;\n            break;\n\n          case 24:\n            _context7.prev = 24;\n            _context7.t1 = _context7[\"catch\"](19);\n            console.log(\"Error in localforage.setItem(\\\"savedWallets\\\", savedWallets) in renameWallet()\");\n            return _context7.abrupt(\"return\", false);\n\n          case 28:\n            return _context7.abrupt(\"return\", true);\n\n          case 29:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, null, null, [[0, 6], [19, 24]], Promise);\n  };\n\n  var deleteWallet = function deleteWallet(walletToBeDeleted) {\n    var savedWallets, walletFoundAndRemoved, i;\n    return _regeneratorRuntime.async(function deleteWallet$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            _context8.prev = 0;\n            _context8.next = 3;\n            return _regeneratorRuntime.awrap(localforage.getItem('savedWallets'));\n\n          case 3:\n            savedWallets = _context8.sent;\n            _context8.next = 11;\n            break;\n\n          case 6:\n            _context8.prev = 6;\n            _context8.t0 = _context8[\"catch\"](0);\n            console.log(\"Error in await localforage.getItem(\\\"savedWallets\\\") in deleteWallet\");\n            console.log(_context8.t0);\n            return _context8.abrupt(\"return\", false);\n\n          case 11:\n            walletFoundAndRemoved = false;\n\n            for (i = 0; i < savedWallets.length; i += 1) {\n              if (savedWallets[i].name === walletToBeDeleted.name) {\n                if (savedWallets[i].mnemonic === walletToBeDeleted.mnemonic) {\n                  savedWallets.splice(i, 1);\n                  walletFoundAndRemoved = true;\n                }\n              }\n            }\n\n            if (walletFoundAndRemoved) {\n              _context8.next = 15;\n              break;\n            }\n\n            return _context8.abrupt(\"return\", false);\n\n          case 15:\n            _context8.prev = 15;\n            _context8.next = 18;\n            return _regeneratorRuntime.awrap(localforage.setItem('savedWallets', savedWallets));\n\n          case 18:\n            _context8.next = 24;\n            break;\n\n          case 20:\n            _context8.prev = 20;\n            _context8.t1 = _context8[\"catch\"](15);\n            console.log(\"Error in localforage.setItem(\\\"savedWallets\\\", savedWallets) in deleteWallet()\");\n            return _context8.abrupt(\"return\", false);\n\n          case 24:\n            return _context8.abrupt(\"return\", true);\n\n          case 25:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, null, null, [[0, 6], [15, 20]], Promise);\n  };\n\n  var addNewSavedWallet = function addNewSavedWallet(importMnemonic) {\n    var lang, Bip39128BitMnemonic, newSavedWallet, savedWallets, i;\n    return _regeneratorRuntime.async(function addNewSavedWallet$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            lang = 'english';\n            Bip39128BitMnemonic = importMnemonic ? importMnemonic : BCH.Mnemonic.generate(128, BCH.Mnemonic.wordLists()[lang]);\n            _context9.next = 4;\n            return _regeneratorRuntime.awrap(getWalletDetails({\n              mnemonic: Bip39128BitMnemonic.toString()\n            }));\n\n          case 4:\n            newSavedWallet = _context9.sent;\n            _context9.prev = 5;\n            _context9.next = 8;\n            return _regeneratorRuntime.awrap(localforage.getItem('savedWallets'));\n\n          case 8:\n            savedWallets = _context9.sent;\n\n            if (savedWallets === null) {\n              savedWallets = [];\n            }\n\n            _context9.next = 17;\n            break;\n\n          case 12:\n            _context9.prev = 12;\n            _context9.t0 = _context9[\"catch\"](5);\n            console.log(\"Error in savedWallets = await localforage.getItem(\\\"savedWallets\\\") in addNewSavedWallet()\");\n            console.log(_context9.t0);\n            console.log(\"savedWallets in error state\", savedWallets);\n\n          case 17:\n            if (!importMnemonic) {\n              _context9.next = 27;\n              break;\n            }\n\n            i = 0;\n\n          case 19:\n            if (!(i < savedWallets.length)) {\n              _context9.next = 27;\n              break;\n            }\n\n            if (!(savedWallets[i].mnemonic === importMnemonic)) {\n              _context9.next = 24;\n              break;\n            }\n\n            console.log(\"Error: this wallet already exists in savedWallets\");\n            console.log(\"Wallet not being added.\");\n            return _context9.abrupt(\"return\", false);\n\n          case 24:\n            i += 1;\n            _context9.next = 19;\n            break;\n\n          case 27:\n            savedWallets.push(newSavedWallet);\n            _context9.prev = 28;\n            _context9.next = 31;\n            return _regeneratorRuntime.awrap(localforage.setItem('savedWallets', savedWallets));\n\n          case 31:\n            _context9.next = 38;\n            break;\n\n          case 33:\n            _context9.prev = 33;\n            _context9.t1 = _context9[\"catch\"](28);\n            console.log(\"Error in localforage.setItem(\\\"savedWallets\\\", activeWallet) called in createWallet with \" + importMnemonic);\n            console.log(\"savedWallets\", savedWallets);\n            console.log(_context9.t1);\n\n          case 38:\n            return _context9.abrupt(\"return\", true);\n\n          case 39:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, null, null, [[5, 12], [28, 33]], Promise);\n  };\n\n  var _createWallet = function createWallet(importMnemonic) {\n    var lang, Bip39128BitMnemonic, wallet;\n    return _regeneratorRuntime.async(function createWallet$(_context10) {\n      while (1) {\n        switch (_context10.prev = _context10.next) {\n          case 0:\n            lang = 'english';\n            Bip39128BitMnemonic = importMnemonic ? importMnemonic : BCH.Mnemonic.generate(128, BCH.Mnemonic.wordLists()[lang]);\n            _context10.next = 4;\n            return _regeneratorRuntime.awrap(getWalletDetails({\n              mnemonic: Bip39128BitMnemonic.toString()\n            }));\n\n          case 4:\n            wallet = _context10.sent;\n            _context10.prev = 5;\n            _context10.next = 8;\n            return _regeneratorRuntime.awrap(localforage.setItem('wallet', wallet));\n\n          case 8:\n            _context10.next = 14;\n            break;\n\n          case 10:\n            _context10.prev = 10;\n            _context10.t0 = _context10[\"catch\"](5);\n            console.log(\"Error setting wallet to wallet indexedDb in createWallet()\");\n            console.log(_context10.t0);\n\n          case 14:\n            _context10.prev = 14;\n            _context10.next = 17;\n            return _regeneratorRuntime.awrap(localforage.setItem('savedWallets', [wallet]));\n\n          case 17:\n            _context10.next = 23;\n            break;\n\n          case 19:\n            _context10.prev = 19;\n            _context10.t1 = _context10[\"catch\"](14);\n            console.log(\"Error setting wallet to savedWallets indexedDb in createWallet()\");\n            console.log(_context10.t1);\n\n          case 23:\n            return _context10.abrupt(\"return\", wallet);\n\n          case 24:\n          case \"end\":\n            return _context10.stop();\n        }\n      }\n    }, null, null, [[5, 10], [14, 19]], Promise);\n  };\n\n  var validateMnemonic = function validateMnemonic(mnemonic) {\n    var wordlist = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : BCH.Mnemonic.wordLists().english;\n    var mnemonicTestOutput;\n\n    try {\n      mnemonicTestOutput = BCH.Mnemonic.validate(mnemonic, wordlist);\n\n      if (mnemonicTestOutput === 'Valid mnemonic') {\n        return true;\n      } else {\n        return false;\n      }\n    } catch (err) {\n      console.log(err);\n      return false;\n    }\n  };\n\n  var handleUpdateWallet = function handleUpdateWallet(setWallet) {\n    var wallet;\n    return _regeneratorRuntime.async(function handleUpdateWallet$(_context11) {\n      while (1) {\n        switch (_context11.prev = _context11.next) {\n          case 0:\n            _context11.next = 2;\n            return _regeneratorRuntime.awrap(getWallet());\n\n          case 2:\n            wallet = _context11.sent;\n            setWallet(wallet);\n\n          case 4:\n          case \"end\":\n            return _context11.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n\n  if ((ws === null || ws.readyState !== 1) && previousBalances && balances && 'totalBalance' in previousBalances && 'totalBalance' in balances && new BigNumber(balances.totalBalance).minus(previousBalances.totalBalance).gt(0)) {\n    notification.success({\n      message: 'Transaction received',\n      description: React.createElement(Paragraph, {\n        __self: _this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 603,\n          columnNumber: 17\n        }\n      }, \"You received\", ' ', Number(balances.totalBalance - previousBalances.totalBalance).toFixed(8), ' ', \"BCH!\"),\n      duration: 3\n    });\n  }\n\n  if (tokens && tokens[0] && tokens[0].balance && previousTokens && previousTokens[0] && previousTokens[0].balance) {\n    if (tokens.length > previousTokens.length) {\n      var tokenIds = tokens.map(function (_ref3) {\n        var tokenId = _ref3.tokenId;\n        return tokenId;\n      });\n      var previousTokenIds = previousTokens.map(function (_ref4) {\n        var tokenId = _ref4.tokenId;\n        return tokenId;\n      });\n      var newTokenIdArr = tokenIds.filter(function (tokenId) {\n        return !previousTokenIds.includes(tokenId);\n      });\n      var newTokenId = newTokenIdArr[0];\n      var receivedTokenObjectIndex = tokens.findIndex(function (x) {\n        return x.tokenId === newTokenId;\n      });\n      var receivedSlpQty = tokens[receivedTokenObjectIndex].balance.toString();\n      var receivedSlpTicker = tokens[receivedTokenObjectIndex].info.tokenTicker;\n      var receivedSlpName = tokens[receivedTokenObjectIndex].info.tokenName;\n\n      if (receivedSlpQty > 0) {\n        notification.success({\n          message: currency.tokenTicker + \" Transaction received: \" + receivedSlpTicker,\n          description: React.createElement(Paragraph, {\n            __self: _this,\n            __source: {\n              fileName: _jsxFileName,\n              lineNumber: 672,\n              columnNumber: 25\n            }\n          }, \"You received \", receivedSlpQty, \" \", receivedSlpName),\n          duration: 5\n        });\n      }\n    } else {\n      for (var i = 0; i < tokens.length; i += 1) {\n        if (tokens[i].balance.gt(previousTokens[i].balance)) {\n          if (previousTokens[i].tokenId !== tokens[i].tokenId) {\n            console.log(\"TokenIds do not match, breaking from SLP notifications\");\n            break;\n          }\n\n          var _receivedSlpQty = tokens[i].balance.minus(previousTokens[i].balance);\n\n          var _receivedSlpTicker = tokens[i].info.tokenTicker;\n          var _receivedSlpName = tokens[i].info.tokenName;\n          notification.success({\n            message: \"SLP Transaction received: \" + _receivedSlpTicker,\n            description: React.createElement(Paragraph, {\n              __self: _this,\n              __source: {\n                fileName: _jsxFileName,\n                lineNumber: 708,\n                columnNumber: 29\n              }\n            }, \"You received \", _receivedSlpQty.toString(), ' ', _receivedSlpName),\n            duration: 5\n          });\n        }\n      }\n    }\n  }\n\n  useAsyncTimeout(function _callee() {\n    return _regeneratorRuntime.async(function _callee$(_context12) {\n      while (1) {\n        switch (_context12.prev = _context12.next) {\n          case 0:\n            fetchBchPrice();\n\n          case 1:\n          case \"end\":\n            return _context12.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  }, 60000);\n  useAsyncTimeout(function _callee2() {\n    var wallet;\n    return _regeneratorRuntime.async(function _callee2$(_context13) {\n      while (1) {\n        switch (_context13.prev = _context13.next) {\n          case 0:\n            _context13.next = 2;\n            return _regeneratorRuntime.awrap(getWallet());\n\n          case 2:\n            wallet = _context13.sent;\n\n            _update({\n              wallet: wallet,\n              setWalletState: setWalletState\n            }).finally(function () {\n              setLoading(false);\n            });\n\n          case 4:\n          case \"end\":\n            return _context13.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  }, 10000);\n\n  var initializeWebsocket = function initializeWebsocket(cashAddress, slpAddress) {\n    if (ws !== null && ws.readyState !== 1) {\n      ws.close();\n      setWs(null);\n    } else if (ws !== null) {\n        var previousWsCashAddress = previousWallet.Path145.legacyAddress;\n        var previousWsSlpAddress = previousWallet.Path245.legacyAddress;\n\n        try {\n          ws.send(JSON.stringify({\n            op: 'addr_unsub',\n            addr: previousWsCashAddress\n          }));\n          console.log(\"Unsubscribed from BCH address at \" + previousWsCashAddress);\n          ws.send(JSON.stringify({\n            op: 'addr_unsub',\n            addr: previousWsSlpAddress\n          }));\n          console.log(\"Unsubscribed from SLP address at \" + previousWsSlpAddress);\n          ws.send(JSON.stringify({\n            op: 'addr_sub',\n            addr: cashAddress\n          }));\n          console.log(\"Subscribed to BCH address at \" + cashAddress);\n          ws.send(JSON.stringify({\n            op: 'addr_sub',\n            addr: slpAddress\n          }));\n          console.log(\"Subscribed to SLP address at \" + slpAddress);\n\n          ws.onmessage = function (e) {\n            var incomingTx = JSON.parse(e.data);\n            console.log(incomingTx);\n            var bchSatsReceived = 0;\n\n            if (incomingTx && incomingTx.x && incomingTx.x.inputs && incomingTx.x.out) {\n              var inputs = incomingTx.x.inputs;\n\n              for (var _i2 = 0; _i2 < inputs.length; _i2 += 1) {\n                if (inputs[_i2].prev_out.addr === cashAddress || inputs[_i2].prev_out.addr === slpAddress) {\n                  return;\n                }\n              }\n\n              var outputs = incomingTx.x.out;\n\n              for (var _i3 = 0; _i3 < outputs.length; _i3 += 1) {\n                if (outputs[_i3].addr === cashAddress) {\n                  bchSatsReceived += outputs[_i3].value;\n                }\n\n                if (outputs[_i3].addr === slpAddress) {\n                  console.log(\"SLP transaction received\");\n                }\n              }\n            }\n\n            if (bchSatsReceived > 0) {\n              notification.success({\n                message: 'Transaction received',\n                description: React.createElement(Paragraph, {\n                  __self: _this,\n                  __source: {\n                    fileName: _jsxFileName,\n                    lineNumber: 865,\n                    columnNumber: 33\n                  }\n                }, \"You received \", bchSatsReceived / 1e8, \" BCH!\"),\n                duration: 3\n              });\n            }\n          };\n        } catch (err) {\n          console.log(\"Error attempting to configure websocket for new wallet\");\n          console.log(err);\n          console.log(\"Closing connection\");\n          ws.close();\n          setWs(null);\n        }\n      } else {\n        var newWs = new WebSocket('wss://ws.blockchain.info/bch/inv');\n\n        newWs.onopen = function () {\n          console.log(\"Connected to bchWs\");\n          newWs.send(JSON.stringify({\n            op: 'addr_sub',\n            addr: cashAddress\n          }));\n          console.log(\"Subscribed to BCH address at \" + cashAddress);\n          newWs.send(JSON.stringify({\n            op: 'addr_sub',\n            addr: slpAddress\n          }));\n          console.log(\"Subscribed to SLP address at \" + slpAddress);\n        };\n\n        newWs.onerror = function (e) {\n          console.log(\"Error in websocket connection for \" + newWs);\n          console.log(e);\n          setWs(null);\n        };\n\n        newWs.onclose = function () {\n          console.log(\"Websocket connection closed\");\n          newWs.send(JSON.stringify({\n            op: 'addr_unsub',\n            addr: cashAddress\n          }));\n          console.log(\"Unsubscribed from BCH address at \" + cashAddress);\n          newWs.send(JSON.stringify({\n            op: 'addr_sub',\n            addr: slpAddress\n          }));\n          console.log(\"Unsubscribed from SLP address at \" + slpAddress);\n        };\n\n        newWs.onmessage = function (e) {\n          var incomingTx = JSON.parse(e.data);\n          console.log(incomingTx);\n          var bchSatsReceived = 0;\n\n          if (incomingTx && incomingTx.x && incomingTx.x.inputs && incomingTx.x.out) {\n            var inputs = incomingTx.x.inputs;\n\n            for (var _i4 = 0; _i4 < inputs.length; _i4 += 1) {\n              if (inputs[_i4].prev_out.addr === cashAddress || inputs[_i4].prev_out.addr === slpAddress) {\n                return;\n              }\n            }\n\n            var outputs = incomingTx.x.out;\n\n            for (var _i5 = 0; _i5 < outputs.length; _i5 += 1) {\n              if (outputs[_i5].addr === cashAddress) {\n                bchSatsReceived += outputs[_i5].value;\n              }\n\n              if (outputs[_i5].addr === slpAddress) {\n                console.log(\"SLP transaction received\");\n              }\n            }\n          }\n\n          if (bchSatsReceived > 0) {\n            notification.success({\n              message: 'Transaction received',\n              description: React.createElement(Paragraph, {\n                __self: _this,\n                __source: {\n                  fileName: _jsxFileName,\n                  lineNumber: 997,\n                  columnNumber: 29\n                }\n              }, \"You received \", bchSatsReceived / 1e8, \" BCH!\"),\n              duration: 3\n            });\n          }\n        };\n\n        setWs(newWs);\n      }\n  };\n\n  var fetchBchPrice = function fetchBchPrice() {\n    var cryptoId, fiatCode, priceApiUrl, bchPrice, bchPriceJson, bchPriceInFiat;\n    return _regeneratorRuntime.async(function fetchBchPrice$(_context14) {\n      while (1) {\n        switch (_context14.prev = _context14.next) {\n          case 0:\n            cryptoId = currency.coingeckoId;\n            fiatCode = 'usd';\n            priceApiUrl = \"https://api.coingecko.com/api/v3/simple/price?ids=\" + cryptoId + \"&vs_currencies=\" + fiatCode + \"&include_last_updated_at=true\";\n            _context14.prev = 3;\n            _context14.next = 6;\n            return _regeneratorRuntime.awrap(fetch(priceApiUrl));\n\n          case 6:\n            bchPrice = _context14.sent;\n            _context14.next = 13;\n            break;\n\n          case 9:\n            _context14.prev = 9;\n            _context14.t0 = _context14[\"catch\"](3);\n            console.log(\"Error fetching BCH Price\");\n            console.log(_context14.t0);\n\n          case 13:\n            _context14.prev = 13;\n            _context14.next = 16;\n            return _regeneratorRuntime.awrap(bchPrice.json());\n\n          case 16:\n            bchPriceJson = _context14.sent;\n            bchPriceInFiat = bchPriceJson[cryptoId][fiatCode];\n            setFiatPrice(bchPriceInFiat);\n            _context14.next = 25;\n            break;\n\n          case 21:\n            _context14.prev = 21;\n            _context14.t1 = _context14[\"catch\"](13);\n            console.log(\"Error parsing price API response to JSON\");\n            console.log(_context14.t1);\n\n          case 25:\n          case \"end\":\n            return _context14.stop();\n        }\n      }\n    }, null, null, [[3, 9], [13, 21]], Promise);\n  };\n\n  useEffect(function () {\n    handleUpdateWallet(setWallet);\n    fetchBchPrice();\n  }, []);\n  useEffect(function () {\n    if (wallet && wallet.Path145 && wallet.Path145.cashAddress && wallet.Path245 && wallet.Path245.cashAddress) {\n      if (currency.useBlockchainWs) {\n        initializeWebsocket(wallet.Path145.legacyAddress, wallet.Path245.legacyAddress);\n      }\n    }\n  }, [wallet]);\n  return {\n    BCH: BCH,\n    wallet: wallet,\n    fiatPrice: fiatPrice,\n    slpBalancesAndUtxos: slpBalancesAndUtxos,\n    balances: balances,\n    tokens: tokens,\n    txHistory: txHistory,\n    loading: loading,\n    apiError: apiError,\n    getWallet: getWallet,\n    validateMnemonic: validateMnemonic,\n    getWalletDetails: getWalletDetails,\n    getSavedWallets: getSavedWallets,\n    update: function update() {\n      return _regeneratorRuntime.async(function update$(_context15) {\n        while (1) {\n          switch (_context15.prev = _context15.next) {\n            case 0:\n              _context15.t0 = _update;\n              _context15.next = 3;\n              return _regeneratorRuntime.awrap(getWallet());\n\n            case 3:\n              _context15.t1 = _context15.sent;\n              _context15.t2 = setLoading;\n              _context15.t3 = setWalletState;\n              _context15.t4 = {\n                wallet: _context15.t1,\n                setLoading: _context15.t2,\n                setWalletState: _context15.t3\n              };\n              return _context15.abrupt(\"return\", (0, _context15.t0)(_context15.t4));\n\n            case 8:\n            case \"end\":\n              return _context15.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    },\n    createWallet: function createWallet(importMnemonic) {\n      var newWallet;\n      return _regeneratorRuntime.async(function createWallet$(_context16) {\n        while (1) {\n          switch (_context16.prev = _context16.next) {\n            case 0:\n              setLoading(true);\n              _context16.next = 3;\n              return _regeneratorRuntime.awrap(_createWallet(importMnemonic));\n\n            case 3:\n              newWallet = _context16.sent;\n              setWallet(newWallet);\n\n              _update({\n                wallet: newWallet,\n                setWalletState: setWalletState\n              }).finally(function () {\n                return setLoading(false);\n              });\n\n            case 6:\n            case \"end\":\n              return _context16.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    },\n    activateWallet: function activateWallet(walletToActivate) {\n      var newWallet;\n      return _regeneratorRuntime.async(function activateWallet$(_context17) {\n        while (1) {\n          switch (_context17.prev = _context17.next) {\n            case 0:\n              setLoading(true);\n              _context17.next = 3;\n              return _regeneratorRuntime.awrap(_activateWallet(walletToActivate));\n\n            case 3:\n              newWallet = _context17.sent;\n              setWallet(newWallet);\n\n              _update({\n                wallet: newWallet,\n                setWalletState: setWalletState\n              }).finally(function () {\n                return setLoading(false);\n              });\n\n            case 6:\n            case \"end\":\n              return _context17.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    },\n    addNewSavedWallet: addNewSavedWallet,\n    renameWallet: renameWallet,\n    deleteWallet: deleteWallet\n  };\n};\n\nexport default useWallet;","map":{"version":3,"sources":["/Users/alcipir/Repos/bitcoin-abc/web/cashtab/mobile/hooks/useWallet.js"],"names":["useState","useEffect","Paragraph","notification","useAsyncTimeout","usePrevious","useBCH","BigNumber","localforage","currency","_","useWallet","wallet","setWallet","fiatPrice","setFiatPrice","ws","setWs","apiError","setApiError","balances","tokens","slpBalancesAndUtxos","txHistory","walletState","setWalletState","getBCH","getUtxos","getSlpBalancesAndUtxos","getTxHistory","loading","setLoading","apiIndex","setApiIndex","BCH","setBCH","utxos","setUtxos","previousBalances","previousTokens","previousWallet","previousUtxos","tryNextAPI","currentApiIndex","apiString","process","env","REACT_APP_BCHA_APIS","apiArray","split","console","log","length","normalizeSlpBalancesAndUtxos","Accounts","Path245","Path145","nonSlpUtxos","forEach","utxo","derivatedAccount","find","account","cashAddress","address","wif","fundingWif","normalizeBalance","totalBalanceInSatoshis","reduce","previousBalance","satoshis","totalBalance","BitcoinCash","toBitcoinCash","deriveAccount","masterHDNode","path","node","HDNode","derivePath","toCashAddress","slpAddress","SLP","Address","toSLPAddress","toWIF","fundingAddress","legacyAddress","toLegacyAddress","haveUtxosChanged","utxoArraysUnchanged","isEqual","update","cashAddresses","isEmpty","error","Error","utxosHaveChanged","newState","getWallet","getItem","existingWallet","JSON","parse","window","localStorage","getWalletDetails","setItem","NETWORK","REACT_APP_NETWORK","mnemonic","Mnemonic","toSeed","rootSeedBuffer","fromSeed","name","slice","getSavedWallets","activeWallet","savedWallets","i","splice","activateWallet","walletToActivate","currentlyActiveWallet","walletInSavedWallets","push","renameWallet","oldName","newName","deleteWallet","walletToBeDeleted","walletFoundAndRemoved","addNewSavedWallet","importMnemonic","lang","Bip39128BitMnemonic","generate","wordLists","toString","newSavedWallet","createWallet","validateMnemonic","wordlist","english","mnemonicTestOutput","validate","err","handleUpdateWallet","readyState","minus","gt","success","message","description","Number","toFixed","duration","balance","tokenIds","map","tokenId","previousTokenIds","newTokenIdArr","filter","includes","newTokenId","receivedTokenObjectIndex","findIndex","x","receivedSlpQty","receivedSlpTicker","info","tokenTicker","receivedSlpName","tokenName","fetchBchPrice","finally","initializeWebsocket","close","previousWsCashAddress","previousWsSlpAddress","send","stringify","op","addr","onmessage","e","incomingTx","data","bchSatsReceived","inputs","out","prev_out","outputs","value","newWs","WebSocket","onopen","onerror","onclose","cryptoId","coingeckoId","fiatCode","priceApiUrl","fetch","bchPrice","json","bchPriceJson","bchPriceInFiat","useBlockchainWs","newWallet"],"mappings":"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","sourcesContent":["/* eslint-disable react-hooks/exhaustive-deps */\n\nimport { useState, useEffect } from 'react';\nimport Paragraph from 'antd/lib/typography/Paragraph';\nimport { notification } from 'antd';\nimport useAsyncTimeout from './useAsyncTimeout';\nimport usePrevious from './usePrevious';\nimport useBCH from './useBCH';\nimport BigNumber from 'bignumber.js';\nimport localforage from 'localforage';\nimport { currency } from '../components/Common/Ticker';\nimport _ from 'lodash';\n\nconst useWallet = () => {\n    const [wallet, setWallet] = useState(false);\n    const [fiatPrice, setFiatPrice] = useState(null);\n    const [ws, setWs] = useState(null);\n    const [apiError, setApiError] = useState(false);\n    const [walletState, setWalletState] = useState({\n        balances: {},\n        tokens: [],\n        slpBalancesAndUtxos: [],\n        txHistory: [],\n    });\n    const { getBCH, getUtxos, getSlpBalancesAndUtxos, getTxHistory } = useBCH();\n    const [loading, setLoading] = useState(true);\n    const [apiIndex, setApiIndex] = useState(0);\n    const [BCH, setBCH] = useState(getBCH(apiIndex));\n    const [utxos, setUtxos] = useState(null);\n    const { balances, tokens, slpBalancesAndUtxos, txHistory } = walletState;\n    const previousBalances = usePrevious(balances);\n    const previousTokens = usePrevious(tokens);\n    const previousWallet = usePrevious(wallet);\n    const previousUtxos = usePrevious(utxos);\n\n    // If you catch API errors, call this function\n    const tryNextAPI = () => {\n        let currentApiIndex = apiIndex;\n        // How many APIs do you have?\n        const apiString = process.env.REACT_APP_BCHA_APIS;\n\n        const apiArray = apiString.split(',');\n\n        console.log(`You have ${apiArray.length} APIs to choose from`);\n        console.log(`Current selection: ${apiIndex}`);\n        // If only one, exit\n        if (apiArray.length === 0) {\n            console.log(\n                `There are no backup APIs, you are stuck with this error`,\n            );\n            return;\n        } else if (currentApiIndex < apiArray.length - 1) {\n            currentApiIndex += 1;\n            console.log(\n                `Incrementing API index from ${apiIndex} to ${currentApiIndex}`,\n            );\n        } else {\n            // Otherwise use the first option again\n            console.log(`Retrying first API index`);\n            currentApiIndex = 0;\n        }\n        //return setApiIndex(currentApiIndex);\n        console.log(`Setting Api Index to ${currentApiIndex}`);\n        setApiIndex(currentApiIndex);\n        return setBCH(getBCH(currentApiIndex));\n        // If you have more than one, use the next one\n        // If you are at the \"end\" of the array, use the first one\n    };\n\n    const normalizeSlpBalancesAndUtxos = (slpBalancesAndUtxos, wallet) => {\n        const Accounts = [wallet.Path245, wallet.Path145];\n        slpBalancesAndUtxos.nonSlpUtxos.forEach(utxo => {\n            const derivatedAccount = Accounts.find(\n                account => account.cashAddress === utxo.address,\n            );\n            utxo.wif = derivatedAccount.fundingWif;\n        });\n\n        return slpBalancesAndUtxos;\n    };\n\n    const normalizeBalance = slpBalancesAndUtxos => {\n        const totalBalanceInSatoshis = slpBalancesAndUtxos.nonSlpUtxos.reduce(\n            (previousBalance, utxo) => previousBalance + utxo.satoshis,\n            0,\n        );\n        return {\n            totalBalanceInSatoshis,\n            totalBalance: BCH.BitcoinCash.toBitcoinCash(totalBalanceInSatoshis),\n        };\n    };\n\n    const deriveAccount = async ({ masterHDNode, path }) => {\n        const node = BCH.HDNode.derivePath(masterHDNode, path);\n        const cashAddress = BCH.HDNode.toCashAddress(node);\n        const slpAddress = BCH.SLP.Address.toSLPAddress(cashAddress);\n\n        return {\n            cashAddress,\n            slpAddress,\n            fundingWif: BCH.HDNode.toWIF(node),\n            fundingAddress: BCH.SLP.Address.toSLPAddress(cashAddress),\n            legacyAddress: BCH.SLP.Address.toLegacyAddress(cashAddress),\n        };\n    };\n\n    const haveUtxosChanged = (utxos, previousUtxos) => {\n        // Relevant points for this array comparing exercise\n        // https://stackoverflow.com/questions/13757109/triple-equal-signs-return-false-for-arrays-in-javascript-why\n        // https://stackoverflow.com/questions/7837456/how-to-compare-arrays-in-javascript\n\n        // If this is initial state\n        if (utxos === null) {\n            // Then make sure to get slpBalancesAndUtxos\n            return true;\n        }\n        // If this is the first time the wallet received utxos\n        if (\n            typeof previousUtxos === 'undefined' ||\n            typeof utxos === 'undefined'\n        ) {\n            // Then they have certainly changed\n            return true;\n        }\n        // return true for empty array, since this means you definitely do not want to skip the next API call\n        if (utxos && utxos.length === 0) {\n            return true;\n        }\n\n        // Compare utxo sets\n        const utxoArraysUnchanged = _.isEqual(utxos, previousUtxos);\n\n        // If utxos are not the same as previousUtxos\n        if (utxoArraysUnchanged) {\n            // then utxos have not changed\n            return false;\n            // otherwise,\n        } else {\n            // utxos have changed\n            return true;\n        }\n    };\n\n    const update = async ({ wallet, setWalletState }) => {\n        //console.log(`tick()`);\n        //console.time(\"update\");\n        try {\n            if (!wallet) {\n                return;\n            }\n            const cashAddresses = [\n                wallet.Path245.cashAddress,\n                wallet.Path145.cashAddress,\n            ];\n\n            const utxos = await getUtxos(BCH, cashAddresses);\n            //console.log(`utxos`, utxos);\n\n            // If an error is returned or utxos from only 1 address are returned\n            if (!utxos || _.isEmpty(utxos) || utxos.error || utxos.length < 2) {\n                // Throw error here to prevent more attempted api calls\n                // as you are likely already at rate limits\n                throw new Error('Error fetching utxos');\n            }\n            setUtxos(utxos);\n\n            const utxosHaveChanged = haveUtxosChanged(utxos, previousUtxos);\n\n            // If the utxo set has not changed,\n            if (!utxosHaveChanged) {\n                // remove api error here; otherwise it will remain if recovering from a rate\n                // limit error with an unchanged utxo set\n                setApiError(false);\n                // then walletState has not changed and does not need to be updated\n                //console.timeEnd(\"update\");\n                return;\n            }\n\n            // todo: another available optimization, update slpBalancesandUtxos by hydrating only the new utxos\n            const slpBalancesAndUtxos = await getSlpBalancesAndUtxos(\n                BCH,\n                utxos,\n            );\n            const txHistory = await getTxHistory(BCH, cashAddresses);\n\n            console.log(`slpBalancesAndUtxos`, slpBalancesAndUtxos);\n            if (typeof slpBalancesAndUtxos === 'undefined') {\n                console.log(`slpBalancesAndUtxos is undefined`);\n                throw new Error('slpBalancesAndUtxos is undefined');\n            }\n            const { tokens } = slpBalancesAndUtxos;\n\n            const newState = {\n                balances: {},\n                tokens: [],\n                slpBalancesAndUtxos: [],\n            };\n\n            newState.slpBalancesAndUtxos = normalizeSlpBalancesAndUtxos(\n                slpBalancesAndUtxos,\n                wallet,\n            );\n\n            newState.balances = normalizeBalance(slpBalancesAndUtxos);\n\n            newState.tokens = tokens;\n\n            newState.txHistory = txHistory;\n\n            setWalletState(newState);\n\n            // If everything executed correctly, remove apiError\n            setApiError(false);\n        } catch (error) {\n            console.log(`Error in update({wallet, setWalletState})`);\n            console.log(error);\n            // Set this in state so that transactions are disabled until the issue is resolved\n            setApiError(true);\n            //console.timeEnd(\"update\");\n            // Try another endpoint\n            console.log(`Trying next API...`);\n            tryNextAPI();\n        }\n        //console.timeEnd(\"update\");\n    };\n\n    const getWallet = async () => {\n        let wallet;\n        try {\n            let existingWallet;\n            try {\n                existingWallet = await localforage.getItem('wallet');\n                // If not in localforage then existingWallet = false, check localstorage\n                if (!existingWallet) {\n                    console.log(`no existing wallet, checking local storage`);\n                    existingWallet = JSON.parse(\n                        window.localStorage.getItem('wallet'),\n                    );\n                    console.log(\n                        `existingWallet from localStorage`,\n                        existingWallet,\n                    );\n                    // If you find it here, move it to indexedDb\n                    if (existingWallet !== null) {\n                        wallet = await getWalletDetails(existingWallet);\n                        await localforage.setItem('wallet', wallet);\n                        return wallet;\n                    }\n                }\n            } catch (e) {\n                console.log(e);\n                existingWallet = null;\n            }\n            // If no wallet in indexedDb or localforage or caught error above or the initial 'false' is in indexedDB\n            if (existingWallet === null || !existingWallet) {\n                wallet = await getWalletDetails(existingWallet);\n                await localforage.setItem('wallet', wallet);\n            } else {\n                wallet = existingWallet;\n            }\n\n            // todo: only do this if you didn't get it out of storage\n            //wallet = await getWalletDetails(existingWallet);\n            //await localforage.setItem(\"wallet\", wallet);\n        } catch (error) {\n            console.log(error);\n        }\n        return wallet;\n    };\n\n    const getWalletDetails = async wallet => {\n        if (!wallet) {\n            return false;\n        }\n        // Since this info is in localforage now, only get the var\n        const NETWORK = process.env.REACT_APP_NETWORK;\n        const mnemonic = wallet.mnemonic;\n        const rootSeedBuffer = await BCH.Mnemonic.toSeed(mnemonic);\n        let masterHDNode;\n\n        if (NETWORK === `mainnet`)\n            masterHDNode = BCH.HDNode.fromSeed(rootSeedBuffer);\n        else masterHDNode = BCH.HDNode.fromSeed(rootSeedBuffer, 'testnet');\n\n        const Path245 = await deriveAccount({\n            masterHDNode,\n            path: \"m/44'/245'/0'/0/0\",\n        });\n        const Path145 = await deriveAccount({\n            masterHDNode,\n            path: \"m/44'/145'/0'/0/0\",\n        });\n\n        let name = Path145.cashAddress.slice(12, 17);\n        // Only set the name if it does not currently exist\n        if (wallet && wallet.name) {\n            name = wallet.name;\n        }\n\n        return {\n            mnemonic: wallet.mnemonic,\n            name,\n            Path245,\n            Path145,\n        };\n    };\n\n    const getSavedWallets = async activeWallet => {\n        let savedWallets;\n        try {\n            savedWallets = await localforage.getItem('savedWallets');\n            if (savedWallets === null) {\n                savedWallets = [];\n            }\n        } catch (err) {\n            console.log(`Error in getSavedWallets`);\n            console.log(err);\n            savedWallets = [];\n        }\n        // Even though the active wallet is still stored in savedWallets, don't return it in this function\n        for (let i = 0; i < savedWallets.length; i += 1) {\n            if (\n                typeof activeWallet !== 'undefined' &&\n                activeWallet.name &&\n                savedWallets[i].name === activeWallet.name\n            ) {\n                savedWallets.splice(i, 1);\n            }\n        }\n        return savedWallets;\n    };\n\n    const activateWallet = async walletToActivate => {\n        /*\n    If the user is migrating from old version to this version, make sure to save the activeWallet\n\n    1 - check savedWallets for the previously active wallet\n    2 - If not there, add it\n    */\n        let currentlyActiveWallet;\n        try {\n            currentlyActiveWallet = await localforage.getItem('wallet');\n        } catch (err) {\n            console.log(\n                `Error in localforage.getItem(\"wallet\") in activateWallet()`,\n            );\n            return false;\n        }\n        // Get savedwallets\n        let savedWallets;\n        try {\n            savedWallets = await localforage.getItem('savedWallets');\n        } catch (err) {\n            console.log(\n                `Error in localforage.getItem(\"savedWallets\") in activateWallet()`,\n            );\n            return false;\n        }\n\n        // Check savedWallets for currentlyActiveWallet\n        let walletInSavedWallets = false;\n        for (let i = 0; i < savedWallets.length; i += 1) {\n            if (savedWallets[i].name === currentlyActiveWallet.name) {\n                walletInSavedWallets = true;\n            }\n        }\n        if (!walletInSavedWallets) {\n            console.log(`Wallet is not in saved Wallets, adding`);\n            savedWallets.push(currentlyActiveWallet);\n            // resave savedWallets\n            try {\n                // Set walletName as the active wallet\n                await localforage.setItem('savedWallets', savedWallets);\n            } catch (err) {\n                console.log(\n                    `Error in localforage.setItem(\"savedWallets\") in activateWallet()`,\n                );\n            }\n        }\n\n        // Now that we have verified the last wallet was saved, we can activate the new wallet\n        try {\n            await localforage.setItem('wallet', walletToActivate);\n        } catch (err) {\n            console.log(\n                `Error in localforage.setItem(\"wallet\", walletToActivate) in activateWallet()`,\n            );\n            return false;\n        }\n        return walletToActivate;\n    };\n\n    const renameWallet = async (oldName, newName) => {\n        // Load savedWallets\n        let savedWallets;\n        try {\n            savedWallets = await localforage.getItem('savedWallets');\n        } catch (err) {\n            console.log(\n                `Error in await localforage.getItem(\"savedWallets\") in renameWallet`,\n            );\n            console.log(err);\n            return false;\n        }\n        // Verify that no existing wallet has this name\n        for (let i = 0; i < savedWallets.length; i += 1) {\n            if (savedWallets[i].name === newName) {\n                // return an error\n                return false;\n            }\n        }\n\n        // change name of desired wallet\n        for (let i = 0; i < savedWallets.length; i += 1) {\n            if (savedWallets[i].name === oldName) {\n                // Replace the name of this entry with the new name\n                savedWallets[i].name = newName;\n            }\n        }\n        // resave savedWallets\n        try {\n            // Set walletName as the active wallet\n            await localforage.setItem('savedWallets', savedWallets);\n        } catch (err) {\n            console.log(\n                `Error in localforage.setItem(\"savedWallets\", savedWallets) in renameWallet()`,\n            );\n            return false;\n        }\n        return true;\n    };\n\n    const deleteWallet = async walletToBeDeleted => {\n        // delete a wallet\n        // returns true if wallet is successfully deleted\n        // otherwise returns false\n        // Load savedWallets\n        let savedWallets;\n        try {\n            savedWallets = await localforage.getItem('savedWallets');\n        } catch (err) {\n            console.log(\n                `Error in await localforage.getItem(\"savedWallets\") in deleteWallet`,\n            );\n            console.log(err);\n            return false;\n        }\n        // Iterate over to find the wallet to be deleted\n        // Verify that no existing wallet has this name\n        let walletFoundAndRemoved = false;\n        for (let i = 0; i < savedWallets.length; i += 1) {\n            if (savedWallets[i].name === walletToBeDeleted.name) {\n                // Verify it has the same mnemonic too, that's a better UUID\n                if (savedWallets[i].mnemonic === walletToBeDeleted.mnemonic) {\n                    // Delete it\n                    savedWallets.splice(i, 1);\n                    walletFoundAndRemoved = true;\n                }\n            }\n        }\n        // If you don't find the wallet, return false\n        if (!walletFoundAndRemoved) {\n            return false;\n        }\n\n        // Resave savedWallets less the deleted wallet\n        try {\n            // Set walletName as the active wallet\n            await localforage.setItem('savedWallets', savedWallets);\n        } catch (err) {\n            console.log(\n                `Error in localforage.setItem(\"savedWallets\", savedWallets) in deleteWallet()`,\n            );\n            return false;\n        }\n        return true;\n    };\n\n    const addNewSavedWallet = async importMnemonic => {\n        // Add a new wallet to savedWallets from importMnemonic or just new wallet\n        const lang = 'english';\n        // create 128 bit BIP39 mnemonic\n        const Bip39128BitMnemonic = importMnemonic\n            ? importMnemonic\n            : BCH.Mnemonic.generate(128, BCH.Mnemonic.wordLists()[lang]);\n        const newSavedWallet = await getWalletDetails({\n            mnemonic: Bip39128BitMnemonic.toString(),\n        });\n        // Get saved wallets\n        let savedWallets;\n        try {\n            savedWallets = await localforage.getItem('savedWallets');\n            // If this doesn't exist yet, savedWallets === null\n            if (savedWallets === null) {\n                savedWallets = [];\n            }\n        } catch (err) {\n            console.log(\n                `Error in savedWallets = await localforage.getItem(\"savedWallets\") in addNewSavedWallet()`,\n            );\n            console.log(err);\n            console.log(`savedWallets in error state`, savedWallets);\n        }\n        // If this wallet is from an imported mnemonic, make sure it does not already exist in savedWallets\n        if (importMnemonic) {\n            for (let i = 0; i < savedWallets.length; i += 1) {\n                // Check for condition \"importing new wallet that is already in savedWallets\"\n                if (savedWallets[i].mnemonic === importMnemonic) {\n                    // set this as the active wallet to keep name history\n                    console.log(\n                        `Error: this wallet already exists in savedWallets`,\n                    );\n                    console.log(`Wallet not being added.`);\n                    return false;\n                }\n            }\n        }\n        // add newSavedWallet\n        savedWallets.push(newSavedWallet);\n        // update savedWallets\n        try {\n            await localforage.setItem('savedWallets', savedWallets);\n        } catch (err) {\n            console.log(\n                `Error in localforage.setItem(\"savedWallets\", activeWallet) called in createWallet with ${importMnemonic}`,\n            );\n            console.log(`savedWallets`, savedWallets);\n            console.log(err);\n        }\n        return true;\n    };\n\n    const createWallet = async importMnemonic => {\n        const lang = 'english';\n        // create 128 bit BIP39 mnemonic\n        const Bip39128BitMnemonic = importMnemonic\n            ? importMnemonic\n            : BCH.Mnemonic.generate(128, BCH.Mnemonic.wordLists()[lang]);\n        const wallet = await getWalletDetails({\n            mnemonic: Bip39128BitMnemonic.toString(),\n        });\n\n        try {\n            await localforage.setItem('wallet', wallet);\n        } catch (err) {\n            console.log(\n                `Error setting wallet to wallet indexedDb in createWallet()`,\n            );\n            console.log(err);\n        }\n        // Since this function is only called from OnBoarding.js, also add this to the saved wallet\n        try {\n            await localforage.setItem('savedWallets', [wallet]);\n        } catch (err) {\n            console.log(\n                `Error setting wallet to savedWallets indexedDb in createWallet()`,\n            );\n            console.log(err);\n        }\n        return wallet;\n    };\n\n    const validateMnemonic = (\n        mnemonic,\n        wordlist = BCH.Mnemonic.wordLists().english,\n    ) => {\n        let mnemonicTestOutput;\n\n        try {\n            mnemonicTestOutput = BCH.Mnemonic.validate(mnemonic, wordlist);\n\n            if (mnemonicTestOutput === 'Valid mnemonic') {\n                return true;\n            } else {\n                return false;\n            }\n        } catch (err) {\n            console.log(err);\n            return false;\n        }\n    };\n\n    const handleUpdateWallet = async setWallet => {\n        const wallet = await getWallet();\n        setWallet(wallet);\n    };\n\n    // Parse for incoming BCH transactions\n    // Only notify if websocket is not connected\n    if (\n        (ws === null || ws.readyState !== 1) &&\n        previousBalances &&\n        balances &&\n        'totalBalance' in previousBalances &&\n        'totalBalance' in balances &&\n        new BigNumber(balances.totalBalance)\n            .minus(previousBalances.totalBalance)\n            .gt(0)\n    ) {\n        notification.success({\n            message: 'Transaction received',\n            description: (\n                <Paragraph>\n                    You received{' '}\n                    {Number(\n                        balances.totalBalance - previousBalances.totalBalance,\n                    ).toFixed(8)}{' '}\n                    BCH!\n                </Paragraph>\n            ),\n            duration: 3,\n        });\n    }\n\n    // Parse for incoming SLP transactions\n    if (\n        tokens &&\n        tokens[0] &&\n        tokens[0].balance &&\n        previousTokens &&\n        previousTokens[0] &&\n        previousTokens[0].balance\n    ) {\n        // If tokens length is greater than previousTokens length, a new token has been received\n        // Note, a user could receive a new token, AND more of existing tokens in between app updates\n        // In this case, the app will only notify about the new token\n        // TODO better handling for all possible cases to cover this\n        // TODO handle with websockets for better response time, less complicated calc\n        if (tokens.length > previousTokens.length) {\n            // Find the new token\n            const tokenIds = tokens.map(({ tokenId }) => tokenId);\n            const previousTokenIds = previousTokens.map(\n                ({ tokenId }) => tokenId,\n            );\n            //console.log(`tokenIds`, tokenIds);\n            //console.log(`previousTokenIds`, previousTokenIds);\n\n            // An array with the new token Id\n            const newTokenIdArr = tokenIds.filter(\n                tokenId => !previousTokenIds.includes(tokenId),\n            );\n            // It's possible that 2 new tokens were received\n            // To do, handle this case\n            const newTokenId = newTokenIdArr[0];\n            //console.log(newTokenId);\n\n            // How much of this tokenId did you get?\n            // would be at\n\n            // Find where the newTokenId is\n            const receivedTokenObjectIndex = tokens.findIndex(\n                x => x.tokenId === newTokenId,\n            );\n            //console.log(`receivedTokenObjectIndex`, receivedTokenObjectIndex);\n            // Calculate amount received\n            //console.log(`receivedTokenObject:`, tokens[receivedTokenObjectIndex]);\n\n            const receivedSlpQty = tokens[\n                receivedTokenObjectIndex\n            ].balance.toString();\n            const receivedSlpTicker =\n                tokens[receivedTokenObjectIndex].info.tokenTicker;\n            const receivedSlpName =\n                tokens[receivedTokenObjectIndex].info.tokenName;\n            //console.log(`receivedSlpQty`, receivedSlpQty);\n\n            // Notification if you received SLP\n            if (receivedSlpQty > 0) {\n                notification.success({\n                    message: `${currency.tokenTicker} Transaction received: ${receivedSlpTicker}`,\n                    description: (\n                        <Paragraph>\n                            You received {receivedSlpQty} {receivedSlpName}\n                        </Paragraph>\n                    ),\n                    duration: 5,\n                });\n            }\n\n            //\n        } else {\n            // If tokens[i].balance > previousTokens[i].balance, a new SLP tx of an existing token has been received\n            // Note that tokens[i].balance is of type BigNumber\n            for (let i = 0; i < tokens.length; i += 1) {\n                if (tokens[i].balance.gt(previousTokens[i].balance)) {\n                    // Received this token\n                    // console.log(`previousTokenId`, previousTokens[i].tokenId);\n                    // console.log(`currentTokenId`, tokens[i].tokenId);\n\n                    if (previousTokens[i].tokenId !== tokens[i].tokenId) {\n                        console.log(\n                            `TokenIds do not match, breaking from SLP notifications`,\n                        );\n                        // Then don't send the notification\n                        // Also don't 'continue' ; this means you have sent a token, just stop iterating through\n                        break;\n                    }\n                    const receivedSlpQty = tokens[i].balance.minus(\n                        previousTokens[i].balance,\n                    );\n\n                    const receivedSlpTicker = tokens[i].info.tokenTicker;\n                    const receivedSlpName = tokens[i].info.tokenName;\n\n                    notification.success({\n                        message: `SLP Transaction received: ${receivedSlpTicker}`,\n                        description: (\n                            <Paragraph>\n                                You received {receivedSlpQty.toString()}{' '}\n                                {receivedSlpName}\n                            </Paragraph>\n                        ),\n                        duration: 5,\n                    });\n                }\n            }\n        }\n    }\n\n    //  Update price every 1 min\n    useAsyncTimeout(async () => {\n        fetchBchPrice();\n    }, 60000);\n\n    // Update wallet every 10s\n    useAsyncTimeout(async () => {\n        const wallet = await getWallet();\n        update({\n            wallet,\n            setWalletState,\n        }).finally(() => {\n            setLoading(false);\n        });\n    }, 10000);\n\n    const initializeWebsocket = (cashAddress, slpAddress) => {\n        // console.log(`initializeWebsocket(${cashAddress}, ${slpAddress})`);\n        // This function parses 3 cases\n        // 1: edge case, websocket is in state but not properly connected\n        //    > Remove it from state and forget about it, fall back to normal notifications\n        // 2: edge-ish case, websocket is in state and connected but user has changed wallet\n        //    > Unsubscribe from old addresses and subscribe to new ones\n        // 3: most common: app is opening, creating websocket with existing addresses\n\n        // If the websocket is already in state but is not properly connected\n        if (ws !== null && ws.readyState !== 1) {\n            // Forget about it and use conventional notifications\n\n            // Close\n            ws.close();\n            // Remove from state\n            setWs(null);\n        }\n        // If the websocket is in state and connected\n        else if (ws !== null) {\n            // console.log(`Websocket already in state`);\n            // console.log(`ws,`, ws);\n            // instead of initializing websocket, unsubscribe from old addresses and subscribe to new ones\n            const previousWsCashAddress = previousWallet.Path145.legacyAddress;\n            const previousWsSlpAddress = previousWallet.Path245.legacyAddress;\n            try {\n                // Unsubscribe from previous addresses\n                ws.send(\n                    JSON.stringify({\n                        op: 'addr_unsub',\n                        addr: previousWsCashAddress,\n                    }),\n                );\n                console.log(\n                    `Unsubscribed from BCH address at ${previousWsCashAddress}`,\n                );\n                ws.send(\n                    JSON.stringify({\n                        op: 'addr_unsub',\n                        addr: previousWsSlpAddress,\n                    }),\n                );\n                console.log(\n                    `Unsubscribed from SLP address at ${previousWsSlpAddress}`,\n                );\n\n                // Subscribe to new addresses\n                ws.send(\n                    JSON.stringify({\n                        op: 'addr_sub',\n                        addr: cashAddress,\n                    }),\n                );\n                console.log(`Subscribed to BCH address at ${cashAddress}`);\n                // Subscribe to SLP address\n                ws.send(\n                    JSON.stringify({\n                        op: 'addr_sub',\n                        addr: slpAddress,\n                    }),\n                );\n                console.log(`Subscribed to SLP address at ${slpAddress}`);\n                // Reset onmessage; it was previously set with the old addresses\n                // Note this code is exactly identical to lines 431-490\n                // TODO put in function\n                ws.onmessage = e => {\n                    // TODO handle case where receive multiple messages on one incoming transaction\n                    //console.log(`ws msg received`);\n                    const incomingTx = JSON.parse(e.data);\n                    console.log(incomingTx);\n\n                    let bchSatsReceived = 0;\n                    // First, check the inputs\n                    // If cashAddress or slpAddress are in the inputs, then this is a sent tx and should be ignored for notifications\n                    if (\n                        incomingTx &&\n                        incomingTx.x &&\n                        incomingTx.x.inputs &&\n                        incomingTx.x.out\n                    ) {\n                        const inputs = incomingTx.x.inputs;\n                        // Iterate over inputs and see if this transaction was sent by the active wallet\n                        for (let i = 0; i < inputs.length; i += 1) {\n                            if (\n                                inputs[i].prev_out.addr === cashAddress ||\n                                inputs[i].prev_out.addr === slpAddress\n                            ) {\n                                // console.log(`Found a sending tx, not notifying`);\n                                // This is a sent transaction and should be ignored by notification handlers\n                                return;\n                            }\n                        }\n                        // Iterate over outputs to determine receiving address\n                        const outputs = incomingTx.x.out;\n\n                        for (let i = 0; i < outputs.length; i += 1) {\n                            if (outputs[i].addr === cashAddress) {\n                                // console.log(`BCH transaction received`);\n                                bchSatsReceived += outputs[i].value;\n                                // handle\n                            }\n                            if (outputs[i].addr === slpAddress) {\n                                console.log(`SLP transaction received`);\n                                //handle\n                                // you would want to get the slp info using this endpoint:\n                                // https://rest.kingbch.com/v3/slp/txDetails/cb39dd04e07e172a37addfcb1d6e167dc52c01867ba21c9bf8b5acf4dd969a3f\n                                // But it does not work for unconfirmed txs\n                                // Hold off on slp tx notifications for now\n                            }\n                        }\n                    }\n                    // parse for receiving address\n                    // if received at cashAddress, parse for BCH amount, notify BCH received\n                    // if received at slpAddress, parse for token, notify SLP received\n                    // if those checks fail, could be from a 'sent' tx, ignore\n\n                    // Note, when you send an SLP tx, you get SLP change to SLP address and BCH change to BCH address\n\n                    // Also note, when you send an SLP tx, you often have inputs from both BCH and SLP addresses\n\n                    // This causes a sent SLP tx to register 4 times from the websocket\n\n                    // Best way to ignore this is to ignore any incoming utx.x with BCH or SLP address in the inputs\n\n                    // Notification for received BCH\n                    if (bchSatsReceived > 0) {\n                        notification.success({\n                            message: 'Transaction received',\n                            description: (\n                                <Paragraph>\n                                    You received {bchSatsReceived / 1e8} BCH!\n                                </Paragraph>\n                            ),\n                            duration: 3,\n                        });\n                    }\n                };\n            } catch (err) {\n                console.log(\n                    `Error attempting to configure websocket for new wallet`,\n                );\n                console.log(err);\n                console.log(`Closing connection`);\n                ws.close();\n                setWs(null);\n            }\n        } else {\n            // If there is no websocket, create one, subscribe to addresses, and add notifications for incoming BCH transactions\n\n            let newWs = new WebSocket('wss://ws.blockchain.info/bch/inv');\n\n            newWs.onopen = () => {\n                console.log(`Connected to bchWs`);\n\n                // Subscribe to BCH address\n                newWs.send(\n                    JSON.stringify({\n                        op: 'addr_sub',\n                        addr: cashAddress,\n                    }),\n                );\n\n                console.log(`Subscribed to BCH address at ${cashAddress}`);\n                // Subscribe to SLP address\n                newWs.send(\n                    JSON.stringify({\n                        op: 'addr_sub',\n                        addr: slpAddress,\n                    }),\n                );\n                console.log(`Subscribed to SLP address at ${slpAddress}`);\n            };\n            newWs.onerror = e => {\n                // close and set to null\n                console.log(`Error in websocket connection for ${newWs}`);\n                console.log(e);\n                setWs(null);\n            };\n            newWs.onclose = () => {\n                console.log(`Websocket connection closed`);\n                // Unsubscribe on close to prevent double subscribing\n                //{\"op\":\"addr_unsub\", \"addr\":\"$bitcoin_address\"}\n                newWs.send(\n                    JSON.stringify({\n                        op: 'addr_unsub',\n                        addr: cashAddress,\n                    }),\n                );\n                console.log(`Unsubscribed from BCH address at ${cashAddress}`);\n                newWs.send(\n                    JSON.stringify({\n                        op: 'addr_sub',\n                        addr: slpAddress,\n                    }),\n                );\n                console.log(`Unsubscribed from SLP address at ${slpAddress}`);\n            };\n            newWs.onmessage = e => {\n                // TODO handle case where receive multiple messages on one incoming transaction\n                //console.log(`ws msg received`);\n                const incomingTx = JSON.parse(e.data);\n                console.log(incomingTx);\n\n                let bchSatsReceived = 0;\n                // First, check the inputs\n                // If cashAddress or slpAddress are in the inputs, then this is a sent tx and should be ignored for notifications\n                if (\n                    incomingTx &&\n                    incomingTx.x &&\n                    incomingTx.x.inputs &&\n                    incomingTx.x.out\n                ) {\n                    const inputs = incomingTx.x.inputs;\n                    // Iterate over inputs and see if this transaction was sent by the active wallet\n                    for (let i = 0; i < inputs.length; i += 1) {\n                        if (\n                            inputs[i].prev_out.addr === cashAddress ||\n                            inputs[i].prev_out.addr === slpAddress\n                        ) {\n                            // console.log(`Found a sending tx, not notifying`);\n                            // This is a sent transaction and should be ignored by notification handlers\n                            return;\n                        }\n                    }\n                    // Iterate over outputs to determine receiving address\n                    const outputs = incomingTx.x.out;\n\n                    for (let i = 0; i < outputs.length; i += 1) {\n                        if (outputs[i].addr === cashAddress) {\n                            // console.log(`BCH transaction received`);\n                            bchSatsReceived += outputs[i].value;\n                            // handle\n                        }\n                        if (outputs[i].addr === slpAddress) {\n                            console.log(`SLP transaction received`);\n                            //handle\n                            // you would want to get the slp info using this endpoint:\n                            // https://rest.kingbch.com/v3/slp/txDetails/cb39dd04e07e172a37addfcb1d6e167dc52c01867ba21c9bf8b5acf4dd969a3f\n                            // But it does not work for unconfirmed txs\n                            // Hold off on slp tx notifications for now\n                        }\n                    }\n                }\n                // parse for receiving address\n                // if received at cashAddress, parse for BCH amount, notify BCH received\n                // if received at slpAddress, parse for token, notify SLP received\n                // if those checks fail, could be from a 'sent' tx, ignore\n\n                // Note, when you send an SLP tx, you get SLP change to SLP address and BCH change to BCH address\n\n                // Also note, when you send an SLP tx, you often have inputs from both BCH and SLP addresses\n\n                // This causes a sent SLP tx to register 4 times from the websocket\n\n                // Best way to ignore this is to ignore any incoming utx.x with BCH or SLP address in the inputs\n\n                // Notification for received BCH\n                if (bchSatsReceived > 0) {\n                    notification.success({\n                        message: 'Transaction received',\n                        description: (\n                            <Paragraph>\n                                You received {bchSatsReceived / 1e8} BCH!\n                            </Paragraph>\n                        ),\n                        duration: 3,\n                    });\n                }\n            };\n\n            setWs(newWs);\n        }\n    };\n\n    const fetchBchPrice = async () => {\n        // Split this variable out in case coingecko changes\n        const cryptoId = currency.coingeckoId;\n        // Keep currency as a variable as eventually it will be a user setting\n        const fiatCode = 'usd';\n        // Keep this in the code, because different URLs will have different outputs require different parsing\n        const priceApiUrl = `https://api.coingecko.com/api/v3/simple/price?ids=${cryptoId}&vs_currencies=${fiatCode}&include_last_updated_at=true`;\n        let bchPrice;\n        let bchPriceJson;\n        try {\n            bchPrice = await fetch(priceApiUrl);\n            //console.log(`bchPrice`, bchPrice);\n        } catch (err) {\n            console.log(`Error fetching BCH Price`);\n            console.log(err);\n        }\n        try {\n            bchPriceJson = await bchPrice.json();\n            //console.log(`bchPriceJson`, bchPriceJson);\n            const bchPriceInFiat = bchPriceJson[cryptoId][fiatCode];\n            //console.log(`bchPriceInFiat`, bchPriceInFiat);\n            setFiatPrice(bchPriceInFiat);\n        } catch (err) {\n            console.log(`Error parsing price API response to JSON`);\n            console.log(err);\n        }\n    };\n\n    useEffect(() => {\n        handleUpdateWallet(setWallet);\n        fetchBchPrice();\n    }, []);\n\n    useEffect(() => {\n        if (\n            wallet &&\n            wallet.Path145 &&\n            wallet.Path145.cashAddress &&\n            wallet.Path245 &&\n            wallet.Path245.cashAddress\n        ) {\n            if (currency.useBlockchainWs) {\n                initializeWebsocket(\n                    wallet.Path145.legacyAddress,\n                    wallet.Path245.legacyAddress,\n                );\n            }\n        }\n    }, [wallet]);\n\n    return {\n        BCH,\n        wallet,\n        fiatPrice,\n        slpBalancesAndUtxos,\n        balances,\n        tokens,\n        txHistory,\n        loading,\n        apiError,\n        getWallet,\n        validateMnemonic,\n        getWalletDetails,\n        getSavedWallets,\n        update: async () =>\n            update({\n                wallet: await getWallet(),\n                setLoading,\n                setWalletState,\n            }),\n        createWallet: async importMnemonic => {\n            setLoading(true);\n            const newWallet = await createWallet(importMnemonic);\n            setWallet(newWallet);\n            update({\n                wallet: newWallet,\n                setWalletState,\n            }).finally(() => setLoading(false));\n        },\n        activateWallet: async walletToActivate => {\n            setLoading(true);\n            const newWallet = await activateWallet(walletToActivate);\n            setWallet(newWallet);\n            update({\n                wallet: newWallet,\n                setWalletState,\n            }).finally(() => setLoading(false));\n        },\n        addNewSavedWallet,\n        renameWallet,\n        deleteWallet,\n    };\n};\n\nexport default useWallet;\n"]},"metadata":{},"sourceType":"module"}