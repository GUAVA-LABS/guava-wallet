{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport BigNumber from 'bignumber.js';\nimport { currency } from \"../components/Common/Ticker\";\nimport SlpWallet from 'minimal-slp-wallet';\nexport default function useBCH() {\n  var DUST = 0.000005;\n  var SEND_BCH_ERRORS = {\n    INSUFICIENT_FUNDS: 0,\n    NETWORK_ERROR: 1,\n    INSUFFICIENT_PRIORITY: 66,\n    DOUBLE_SPENDING: 18,\n    MAX_UNCONFIRMED_TXS: 64\n  };\n\n  var getRestUrl = function getRestUrl() {\n    var apiIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var apiString = process.env.REACT_APP_NETWORK === \"mainnet\" ? process.env.REACT_APP_BCHA_APIS : process.env.REACT_APP_BCHA_APIS_TEST;\n    var apiArray = apiString.split(',');\n    return apiArray[apiIndex];\n  };\n\n  var getTxHistory = function getTxHistory(BCH, addresses) {\n    var txHistoryResponse;\n    return _regeneratorRuntime.async(function getTxHistory$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.prev = 0;\n            _context.next = 3;\n            return _regeneratorRuntime.awrap(BCH.Electrumx.transactions(addresses));\n\n          case 3:\n            txHistoryResponse = _context.sent;\n\n            if (!(txHistoryResponse.success && txHistoryResponse.transactions)) {\n              _context.next = 8;\n              break;\n            }\n\n            return _context.abrupt(\"return\", txHistoryResponse.transactions);\n\n          case 8:\n            throw new Error('Error in getTxHistory');\n\n          case 9:\n            _context.next = 16;\n            break;\n\n          case 11:\n            _context.prev = 11;\n            _context.t0 = _context[\"catch\"](0);\n            console.log(\"Error in BCH.Electrumx.transactions(addresses):\");\n            console.log(_context.t0);\n            return _context.abrupt(\"return\", _context.t0);\n\n          case 16:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, null, [[0, 11]], Promise);\n  };\n\n  var getUtxos = function getUtxos(BCH, addresses) {\n    var utxosResponse;\n    return _regeneratorRuntime.async(function getUtxos$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.prev = 0;\n            _context2.next = 3;\n            return _regeneratorRuntime.awrap(BCH.Electrumx.utxo(addresses));\n\n          case 3:\n            utxosResponse = _context2.sent;\n            return _context2.abrupt(\"return\", utxosResponse.utxos);\n\n          case 7:\n            _context2.prev = 7;\n            _context2.t0 = _context2[\"catch\"](0);\n            console.log(\"Error in BCH.Electrumx.utxo(addresses):\");\n            return _context2.abrupt(\"return\", _context2.t0);\n\n          case 11:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, null, null, [[0, 7]], Promise);\n  };\n\n  var getHydratedUtxoDetails = function getHydratedUtxoDetails(BCH, utxos) {\n    var hydratedUtxoDetails;\n    return _regeneratorRuntime.async(function getHydratedUtxoDetails$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.prev = 0;\n            _context3.next = 3;\n            return _regeneratorRuntime.awrap(BCH.SLP.Utils.hydrateUtxos(utxos));\n\n          case 3:\n            hydratedUtxoDetails = _context3.sent;\n            return _context3.abrupt(\"return\", hydratedUtxoDetails);\n\n          case 7:\n            _context3.prev = 7;\n            _context3.t0 = _context3[\"catch\"](0);\n            console.log(\"Error in BCH.SLP.Utils.hydrateUtxos(utxosResponse.utxos)\");\n            console.log(_context3.t0);\n            return _context3.abrupt(\"return\", _context3.t0);\n\n          case 12:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, null, null, [[0, 7]], Promise);\n  };\n\n  var getSlpBalancesAndUtxos = function getSlpBalancesAndUtxos(hydratedUtxoDetails) {\n    var hydratedUtxos = [];\n\n    for (var i = 0; i < hydratedUtxoDetails.slpUtxos.length; i += 1) {\n      var hydratedUtxosAtAddress = hydratedUtxoDetails.slpUtxos[i];\n\n      for (var j = 0; j < hydratedUtxosAtAddress.utxos.length; j += 1) {\n        var hydratedUtxo = hydratedUtxosAtAddress.utxos[j];\n        hydratedUtxo.address = hydratedUtxosAtAddress.address;\n        hydratedUtxos.push(hydratedUtxo);\n      }\n    }\n\n    var nullUtxos = hydratedUtxos.filter(function (utxo) {\n      return utxo.isValid === null;\n    });\n\n    if (nullUtxos.length > 0) {\n      console.log(nullUtxos.length + \" null utxos found, ignoring results\");\n      throw new Error('Null utxos found, ignoring results');\n    }\n\n    var nonSlpUtxos = hydratedUtxos.filter(function (utxo) {\n      return utxo.isValid === false && utxo.value !== 546 && !utxo.tokenName;\n    });\n    var slpUtxos = hydratedUtxos.filter(function (utxo) {\n      return utxo.isValid;\n    });\n    var tokensById = {};\n    slpUtxos.forEach(function (slpUtxo) {\n      var token = tokensById[slpUtxo.tokenId];\n\n      if (token) {\n        if (slpUtxo.tokenQty) {\n          token.balance = token.balance.plus(new BigNumber(slpUtxo.tokenQty));\n        }\n\n        if (slpUtxo.utxoType && !token.hasBaton) {\n          token.hasBaton = slpUtxo.utxoType === 'minting-baton';\n        }\n      } else {\n        token = {};\n        token.info = slpUtxo;\n        token.tokenId = slpUtxo.tokenId;\n\n        if (slpUtxo.tokenQty) {\n          token.balance = new BigNumber(slpUtxo.tokenQty);\n        } else {\n          token.balance = new BigNumber(0);\n        }\n\n        if (slpUtxo.utxoType) {\n          token.hasBaton = slpUtxo.utxoType === 'minting-baton';\n        } else {\n          token.hasBaton = false;\n        }\n\n        tokensById[slpUtxo.tokenId] = token;\n      }\n    });\n    var tokens = Object.values(tokensById);\n    return {\n      tokens: tokens,\n      nonSlpUtxos: nonSlpUtxos,\n      slpUtxos: slpUtxos\n    };\n  };\n\n  var calcFee = function calcFee(BCH, utxos) {\n    var p2pkhOutputNumber = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;\n    var satoshisPerByte = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : currency.defaultFee;\n    var byteCount = BCH.BitcoinCash.getByteCount({\n      P2PKH: utxos.length\n    }, {\n      P2PKH: p2pkhOutputNumber\n    });\n    var txFee = Math.ceil(satoshisPerByte * byteCount);\n    return txFee;\n  };\n\n  var sendToken = function sendToken(BCH, wallet, slpBalancesAndUtxos, _ref) {\n    var tokenId, amount, tokenReceiverAddress, largestBchUtxo, bchECPair, tokenUtxos, transactionBuilder, originalAmount, finalTokenAmountSent, tokenAmountBeingSentToAddress, tokenUtxosBeingSpent, i, slpSendObj, slpData, txFee, remainder, redeemScript, _loop, _i, tx, hex, txidStr, link;\n\n    return _regeneratorRuntime.async(function sendToken$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            tokenId = _ref.tokenId, amount = _ref.amount, tokenReceiverAddress = _ref.tokenReceiverAddress;\n\n            if (!(slpBalancesAndUtxos.nonSlpUtxos.length === 0)) {\n              _context4.next = 3;\n              break;\n            }\n\n            throw new Error(\"You need some \" + currency.ticker + \" to send \" + currency.tokenTicker);\n\n          case 3:\n            largestBchUtxo = slpBalancesAndUtxos.nonSlpUtxos.reduce(function (previous, current) {\n              return previous.value > current.value ? previous : current;\n            });\n            bchECPair = BCH.ECPair.fromWIF(largestBchUtxo.wif);\n            tokenUtxos = slpBalancesAndUtxos.slpUtxos.filter(function (utxo, index) {\n              if (utxo && utxo.tokenId === tokenId && utxo.utxoType === 'token') {\n                  return true;\n                }\n\n              return false;\n            });\n\n            if (!(tokenUtxos.length === 0)) {\n              _context4.next = 8;\n              break;\n            }\n\n            throw new Error('No token UTXOs for the specified token could be found.');\n\n          case 8:\n            if (process.env.REACT_APP_NETWORK === 'mainnet') {\n              transactionBuilder = new BCH.TransactionBuilder();\n            } else transactionBuilder = new BCH.TransactionBuilder('testnet');\n\n            originalAmount = largestBchUtxo.value;\n            transactionBuilder.addInput(largestBchUtxo.tx_hash, largestBchUtxo.tx_pos);\n            finalTokenAmountSent = new BigNumber(0);\n            tokenAmountBeingSentToAddress = new BigNumber(amount);\n            tokenUtxosBeingSpent = [];\n            i = 0;\n\n          case 15:\n            if (!(i < tokenUtxos.length)) {\n              _context4.next = 24;\n              break;\n            }\n\n            finalTokenAmountSent = finalTokenAmountSent.plus(new BigNumber(tokenUtxos[i].tokenQty));\n            transactionBuilder.addInput(tokenUtxos[i].tx_hash, tokenUtxos[i].tx_pos);\n            tokenUtxosBeingSpent.push(tokenUtxos[i]);\n\n            if (!tokenAmountBeingSentToAddress.lte(finalTokenAmountSent)) {\n              _context4.next = 21;\n              break;\n            }\n\n            return _context4.abrupt(\"break\", 24);\n\n          case 21:\n            i++;\n            _context4.next = 15;\n            break;\n\n          case 24:\n            slpSendObj = BCH.SLP.TokenType1.generateSendOpReturn(tokenUtxosBeingSpent, tokenAmountBeingSentToAddress.toString());\n            slpData = slpSendObj.script;\n            transactionBuilder.addOutput(slpData, 0);\n            transactionBuilder.addOutput(BCH.SLP.Address.toLegacyAddress(tokenReceiverAddress), 546);\n\n            if (slpSendObj.outputs > 1) {\n              if (wallet.Path1899.legacyAddress) {\n                transactionBuilder.addOutput(wallet.Path1899.legacyAddress, 546);\n              } else {\n                transactionBuilder.addOutput(BCH.SLP.Address.toLegacyAddress(tokenUtxosBeingSpent[0].address), 546);\n              }\n            }\n\n            txFee = calcFee(BCH, tokenUtxosBeingSpent, 5, 1.1 * currency.defaultFee);\n            remainder = originalAmount - txFee - 546 * 2;\n\n            if (!(remainder < 1)) {\n              _context4.next = 33;\n              break;\n            }\n\n            throw new Error('Selected UTXO does not have enough satoshis');\n\n          case 33:\n            if (wallet.Path1899.legacyAddress) {\n              transactionBuilder.addOutput(wallet.Path1899.legacyAddress, remainder);\n            } else {\n              transactionBuilder.addOutput(BCH.Address.toLegacyAddress(largestBchUtxo.address), remainder);\n            }\n\n            transactionBuilder.sign(0, bchECPair, redeemScript, transactionBuilder.hashTypes.SIGHASH_ALL, originalAmount);\n\n            _loop = function _loop(_i) {\n              var thisUtxo = tokenUtxosBeingSpent[_i];\n              var accounts = [wallet.Path245, wallet.Path145, wallet.Path1899];\n              var utxoEcPair = BCH.ECPair.fromWIF(accounts.filter(function (acc) {\n                return acc.cashAddress === thisUtxo.address;\n              }).pop().fundingWif);\n              transactionBuilder.sign(1 + _i, utxoEcPair, redeemScript, transactionBuilder.hashTypes.SIGHASH_ALL, thisUtxo.value);\n            };\n\n            for (_i = 0; _i < tokenUtxosBeingSpent.length; _i++) {\n              _loop(_i);\n            }\n\n            tx = transactionBuilder.build();\n            hex = tx.toHex();\n            _context4.next = 41;\n            return _regeneratorRuntime.awrap(BCH.RawTransactions.sendRawTransaction([hex]));\n\n          case 41:\n            txidStr = _context4.sent;\n\n            if (txidStr && txidStr[0]) {\n              console.log(currency.tokenTicker + \" txid\", txidStr[0]);\n            }\n\n            if (process.env.REACT_APP_NETWORK === \"mainnet\") {\n              link = currency.blockExplorerUrl + \"/tx/\" + txidStr;\n            } else {\n              link = currency.blockExplorerUrlTestnet + \"/tx/\" + txidStr;\n            }\n\n            return _context4.abrupt(\"return\", link);\n\n          case 45:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n\n  var sendBch = function sendBch(BCH, wallet, utxos, _ref2, callbackTxId) {\n    var addresses, values, encodedOpReturn, value, REMAINDER_ADDR, inputUtxos, _transactionBuilder, satoshisToSend, originalAmount, txFee, i, utxo, vout, txid, remainder, error, _i2, address, _i3, _utxo, tx, hex, txidStr, link;\n\n    return _regeneratorRuntime.async(function sendBch$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            addresses = _ref2.addresses, values = _ref2.values, encodedOpReturn = _ref2.encodedOpReturn;\n            _context5.prev = 1;\n\n            if (!(!values || values.length === 0)) {\n              _context5.next = 4;\n              break;\n            }\n\n            return _context5.abrupt(\"return\", null);\n\n          case 4:\n            value = values.reduce(function (previous, current) {\n              return new BigNumber(current).plus(previous);\n            }, new BigNumber(0));\n            REMAINDER_ADDR = wallet.Path1899.cashAddress;\n            inputUtxos = [];\n            if (process.env.REACT_APP_NETWORK === \"mainnet\") _transactionBuilder = new BCH.TransactionBuilder();else _transactionBuilder = new BCH.TransactionBuilder('testnet');\n            satoshisToSend = BCH.BitcoinCash.toSatoshi(value.toFixed(8));\n            originalAmount = new BigNumber(0);\n            txFee = 0;\n            i = 0;\n\n          case 12:\n            if (!(i < utxos.length)) {\n              _context5.next = 25;\n              break;\n            }\n\n            utxo = utxos[i];\n            originalAmount = originalAmount.plus(utxo.value);\n            vout = utxo.vout;\n            txid = utxo.txid;\n\n            _transactionBuilder.addInput(txid, vout);\n\n            inputUtxos.push(utxo);\n            txFee = encodedOpReturn ? calcFee(BCH, inputUtxos, addresses.length + 2) : calcFee(BCH, inputUtxos, addresses.length + 1);\n\n            if (!originalAmount.minus(satoshisToSend).minus(txFee).gte(0)) {\n              _context5.next = 22;\n              break;\n            }\n\n            return _context5.abrupt(\"break\", 25);\n\n          case 22:\n            i++;\n            _context5.next = 12;\n            break;\n\n          case 25:\n            remainder = Math.floor(originalAmount.minus(satoshisToSend).minus(txFee));\n\n            if (!(remainder < 0)) {\n              _context5.next = 30;\n              break;\n            }\n\n            error = new Error(\"Insufficient funds\");\n            error.code = SEND_BCH_ERRORS.INSUFICIENT_FUNDS;\n            throw error;\n\n          case 30:\n            if (encodedOpReturn) {\n              _transactionBuilder.addOutput(encodedOpReturn, 0);\n            }\n\n            for (_i2 = 0; _i2 < addresses.length; _i2++) {\n              address = addresses[_i2];\n\n              _transactionBuilder.addOutput(BCH.Address.toCashAddress(address), BCH.BitcoinCash.toSatoshi(Number(values[_i2]).toFixed(8)));\n            }\n\n            if (remainder >= BCH.BitcoinCash.toSatoshi(DUST)) {\n              _transactionBuilder.addOutput(REMAINDER_ADDR, remainder);\n            }\n\n            for (_i3 = 0; _i3 < inputUtxos.length; _i3++) {\n              _utxo = inputUtxos[_i3];\n\n              _transactionBuilder.sign(_i3, BCH.ECPair.fromWIF(_utxo.wif), undefined, _transactionBuilder.hashTypes.SIGHASH_ALL, _utxo.value);\n            }\n\n            tx = _transactionBuilder.build();\n            hex = tx.toHex();\n            _context5.next = 38;\n            return _regeneratorRuntime.awrap(BCH.RawTransactions.sendRawTransaction([hex]));\n\n          case 38:\n            txidStr = _context5.sent;\n\n            if (txidStr && txidStr[0]) {\n              console.log(currency.ticker + \" txid\", txidStr[0]);\n            }\n\n            if (callbackTxId) {\n              callbackTxId(txidStr);\n            }\n\n            if (process.env.REACT_APP_NETWORK === \"mainnet\") {\n              link = currency.blockExplorerUrl + \"/tx/\" + txidStr;\n            } else {\n              link = currency.blockExplorerUrlTestnet + \"/tx/\" + txidStr;\n            }\n\n            return _context5.abrupt(\"return\", link);\n\n          case 45:\n            _context5.prev = 45;\n            _context5.t0 = _context5[\"catch\"](1);\n\n            if (_context5.t0.error === 'insufficient priority (code 66)') {\n              _context5.t0.code = SEND_BCH_ERRORS.INSUFFICIENT_PRIORITY;\n            } else if (_context5.t0.error === 'txn-mempool-conflict (code 18)') {\n              _context5.t0.code = SEND_BCH_ERRORS.DOUBLE_SPENDING;\n            } else if (_context5.t0.error === 'Network Error') {\n              _context5.t0.code = SEND_BCH_ERRORS.NETWORK_ERROR;\n            } else if (_context5.t0.error === 'too-long-mempool-chain, too many unconfirmed ancestors [limit: 25] (code 64)') {\n              _context5.t0.code = SEND_BCH_ERRORS.MAX_UNCONFIRMED_TXS;\n            }\n\n            console.log(\"error: \", _context5.t0);\n            throw _context5.t0;\n\n          case 50:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, null, null, [[1, 45]], Promise);\n  };\n\n  var getBCH = function getBCH() {\n    var apiIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var ConstructedSlpWallet;\n    ConstructedSlpWallet = new SlpWallet('', {\n      restURL: getRestUrl(apiIndex)\n    });\n    return ConstructedSlpWallet.bchjs;\n  };\n\n  return {\n    getBCH: getBCH,\n    calcFee: calcFee,\n    getUtxos: getUtxos,\n    getHydratedUtxoDetails: getHydratedUtxoDetails,\n    getSlpBalancesAndUtxos: getSlpBalancesAndUtxos,\n    getTxHistory: getTxHistory,\n    getRestUrl: getRestUrl,\n    sendBch: sendBch,\n    sendToken: sendToken\n  };\n}","map":{"version":3,"sources":["/Users/alcipir/Repos/bitcoin-abc/web/cashtab/mobile/hooks/useBCH.js"],"names":["BigNumber","currency","SlpWallet","useBCH","DUST","SEND_BCH_ERRORS","INSUFICIENT_FUNDS","NETWORK_ERROR","INSUFFICIENT_PRIORITY","DOUBLE_SPENDING","MAX_UNCONFIRMED_TXS","getRestUrl","apiIndex","apiString","process","env","REACT_APP_NETWORK","REACT_APP_BCHA_APIS","REACT_APP_BCHA_APIS_TEST","apiArray","split","getTxHistory","BCH","addresses","Electrumx","transactions","txHistoryResponse","success","Error","console","log","getUtxos","utxo","utxosResponse","utxos","getHydratedUtxoDetails","SLP","Utils","hydrateUtxos","hydratedUtxoDetails","getSlpBalancesAndUtxos","hydratedUtxos","i","slpUtxos","length","hydratedUtxosAtAddress","j","hydratedUtxo","address","push","nullUtxos","filter","isValid","nonSlpUtxos","value","tokenName","tokensById","forEach","slpUtxo","token","tokenId","tokenQty","balance","plus","utxoType","hasBaton","info","tokens","Object","values","calcFee","p2pkhOutputNumber","satoshisPerByte","defaultFee","byteCount","BitcoinCash","getByteCount","P2PKH","txFee","Math","ceil","sendToken","wallet","slpBalancesAndUtxos","amount","tokenReceiverAddress","ticker","tokenTicker","largestBchUtxo","reduce","previous","current","bchECPair","ECPair","fromWIF","wif","tokenUtxos","index","transactionBuilder","TransactionBuilder","originalAmount","addInput","tx_hash","tx_pos","finalTokenAmountSent","tokenAmountBeingSentToAddress","tokenUtxosBeingSpent","lte","slpSendObj","TokenType1","generateSendOpReturn","toString","slpData","script","addOutput","Address","toLegacyAddress","outputs","Path1899","legacyAddress","remainder","sign","redeemScript","hashTypes","SIGHASH_ALL","thisUtxo","accounts","Path245","Path145","utxoEcPair","acc","cashAddress","pop","fundingWif","tx","build","hex","toHex","RawTransactions","sendRawTransaction","txidStr","link","blockExplorerUrl","blockExplorerUrlTestnet","sendBch","callbackTxId","encodedOpReturn","REMAINDER_ADDR","inputUtxos","satoshisToSend","toSatoshi","toFixed","vout","txid","minus","gte","floor","error","code","toCashAddress","Number","undefined","getBCH","ConstructedSlpWallet","restURL","bchjs"],"mappings":"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","sourcesContent":["import BigNumber from 'bignumber.js';\nimport { currency } from '../components/Common/Ticker';\nimport SlpWallet from 'minimal-slp-wallet';\n\nexport default function useBCH() {\n    const DUST = 0.000005;\n    const SEND_BCH_ERRORS = {\n        INSUFICIENT_FUNDS: 0,\n        NETWORK_ERROR: 1,\n        INSUFFICIENT_PRIORITY: 66, // ~insufficient fee\n        DOUBLE_SPENDING: 18,\n        MAX_UNCONFIRMED_TXS: 64,\n    };\n\n    const getRestUrl = (apiIndex = 0) => {\n        const apiString =\n            process.env.REACT_APP_NETWORK === `mainnet`\n                ? process.env.REACT_APP_BCHA_APIS\n                : process.env.REACT_APP_BCHA_APIS_TEST;\n        const apiArray = apiString.split(',');\n        return apiArray[apiIndex];\n    };\n\n    const getTxHistory = async (BCH, addresses) => {\n        let txHistoryResponse;\n        try {\n            //console.log(`API Call: BCH.Electrumx.utxo(addresses)`);\n            //console.log(addresses);\n            txHistoryResponse = await BCH.Electrumx.transactions(addresses);\n            //console.log(`BCH.Electrumx.transactions(addresses) succeeded`);\n            //console.log(`txHistoryResponse`, txHistoryResponse);\n            if (txHistoryResponse.success && txHistoryResponse.transactions) {\n                return txHistoryResponse.transactions;\n            } else {\n                // eslint-disable-next-line no-throw-literal\n                throw new Error('Error in getTxHistory');\n            }\n        } catch (err) {\n            console.log(`Error in BCH.Electrumx.transactions(addresses):`);\n            console.log(err);\n            return err;\n        }\n    };\n\n    // Split out the BCH.Electrumx.utxo(addresses) call from the getSlpBalancesandUtxos function\n    // If utxo set has not changed, you do not need to hydrate the utxo set\n    // This drastically reduces calls to the API\n    const getUtxos = async (BCH, addresses) => {\n        let utxosResponse;\n        try {\n            //console.log(`API Call: BCH.Electrumx.utxo(addresses)`);\n            //console.log(addresses);\n            utxosResponse = await BCH.Electrumx.utxo(addresses);\n            //console.log(`BCH.Electrumx.utxo(addresses) succeeded`);\n            //console.log(`utxosResponse`, utxosResponse);\n            return utxosResponse.utxos;\n        } catch (err) {\n            console.log(`Error in BCH.Electrumx.utxo(addresses):`);\n            return err;\n        }\n    };\n\n    const getHydratedUtxoDetails = async (BCH, utxos) => {\n        let hydratedUtxoDetails;\n\n        try {\n            hydratedUtxoDetails = await BCH.SLP.Utils.hydrateUtxos(utxos);\n            return hydratedUtxoDetails;\n        } catch (err) {\n            console.log(\n                `Error in BCH.SLP.Utils.hydrateUtxos(utxosResponse.utxos)`,\n            );\n            console.log(err);\n            return err;\n        }\n    };\n\n    const getSlpBalancesAndUtxos = hydratedUtxoDetails => {\n        const hydratedUtxos = [];\n        for (let i = 0; i < hydratedUtxoDetails.slpUtxos.length; i += 1) {\n            const hydratedUtxosAtAddress = hydratedUtxoDetails.slpUtxos[i];\n            for (let j = 0; j < hydratedUtxosAtAddress.utxos.length; j += 1) {\n                const hydratedUtxo = hydratedUtxosAtAddress.utxos[j];\n                hydratedUtxo.address = hydratedUtxosAtAddress.address;\n                hydratedUtxos.push(hydratedUtxo);\n            }\n        }\n\n        //console.log(`hydratedUtxos`, hydratedUtxos);\n\n        // WARNING\n        // If you hit rate limits, your above utxos object will come back with `isValid` as null, but otherwise ok\n        // You need to throw an error before setting nonSlpUtxos and slpUtxos in this case\n        const nullUtxos = hydratedUtxos.filter(utxo => utxo.isValid === null);\n        //console.log(`nullUtxos`, nullUtxos);\n        if (nullUtxos.length > 0) {\n            console.log(\n                `${nullUtxos.length} null utxos found, ignoring results`,\n            );\n            throw new Error('Null utxos found, ignoring results');\n        }\n\n        // Prevent app from treating slpUtxos as nonSlpUtxos\n        // Must enforce === false as api will occasionally return utxo.isValid === null\n        // Do not classify utxos with 546 satoshis as nonSlpUtxos as a precaution\n        // Do not classify any utxos that include token information as nonSlpUtxos\n        const nonSlpUtxos = hydratedUtxos.filter(\n            utxo =>\n                utxo.isValid === false && utxo.value !== 546 && !utxo.tokenName,\n        );\n        const slpUtxos = hydratedUtxos.filter(utxo => utxo.isValid);\n\n        let tokensById = {};\n\n        slpUtxos.forEach(slpUtxo => {\n            let token = tokensById[slpUtxo.tokenId];\n\n            if (token) {\n                // Minting baton does nto have a slpUtxo.tokenQty type\n\n                if (slpUtxo.tokenQty) {\n                    token.balance = token.balance.plus(\n                        new BigNumber(slpUtxo.tokenQty),\n                    );\n                }\n\n                //token.hasBaton = slpUtxo.transactionType === \"genesis\";\n                if (slpUtxo.utxoType && !token.hasBaton) {\n                    token.hasBaton = slpUtxo.utxoType === 'minting-baton';\n                }\n\n                // Examples of slpUtxo\n                /*\n                Genesis transaction:\n                {\n                address: \"bitcoincash:qrhzv5t79e2afc3rdutcu0d3q20gl7ul3ue58whah6\"\n                decimals: 9\n                height: 617564\n                isValid: true\n                satoshis: 546\n                tokenDocumentHash: \"\"\n                tokenDocumentUrl: \"developer.bitcoin.com\"\n                tokenId: \"6c41f244676ecfcbe3b4fabee2c72c2dadf8d74f8849afabc8a549157db69199\"\n                tokenName: \"PiticoLaunch\"\n                tokenTicker: \"PTCL\"\n                tokenType: 1\n                tx_hash: \"6c41f244676ecfcbe3b4fabee2c72c2dadf8d74f8849afabc8a549157db69199\"\n                tx_pos: 2\n                txid: \"6c41f244676ecfcbe3b4fabee2c72c2dadf8d74f8849afabc8a549157db69199\"\n                utxoType: \"minting-baton\"\n                value: 546\n                vout: 2\n                }\n\n                Send transaction:\n                {\n                address: \"bitcoincash:qrhzv5t79e2afc3rdutcu0d3q20gl7ul3ue58whah6\"\n                decimals: 9\n                height: 655115\n                isValid: true\n                satoshis: 546\n                tokenDocumentHash: \"\"\n                tokenDocumentUrl: \"developer.bitcoin.com\"\n                tokenId: \"6c41f244676ecfcbe3b4fabee2c72c2dadf8d74f8849afabc8a549157db69199\"\n                tokenName: \"PiticoLaunch\"\n                tokenQty: 1.123456789\n                tokenTicker: \"PTCL\"\n                tokenType: 1\n                transactionType: \"send\"\n                tx_hash: \"dea400f963bc9f51e010f88533010f8d1f82fc2bcc485ff8500c3a82b25abd9e\"\n                tx_pos: 1\n                txid: \"dea400f963bc9f51e010f88533010f8d1f82fc2bcc485ff8500c3a82b25abd9e\"\n                utxoType: \"token\"\n                value: 546\n                vout: 1\n                }\n                */\n            } else {\n                token = {};\n                token.info = slpUtxo;\n                token.tokenId = slpUtxo.tokenId;\n                if (slpUtxo.tokenQty) {\n                    token.balance = new BigNumber(slpUtxo.tokenQty);\n                } else {\n                    token.balance = new BigNumber(0);\n                }\n                if (slpUtxo.utxoType) {\n                    token.hasBaton = slpUtxo.utxoType === 'minting-baton';\n                } else {\n                    token.hasBaton = false;\n                }\n\n                tokensById[slpUtxo.tokenId] = token;\n            }\n        });\n\n        const tokens = Object.values(tokensById);\n        // console.log(`tokens`, tokens);\n        return {\n            tokens,\n            nonSlpUtxos,\n            slpUtxos,\n        };\n    };\n\n    const calcFee = (\n        BCH,\n        utxos,\n        p2pkhOutputNumber = 2,\n        satoshisPerByte = currency.defaultFee,\n    ) => {\n        const byteCount = BCH.BitcoinCash.getByteCount(\n            { P2PKH: utxos.length },\n            { P2PKH: p2pkhOutputNumber },\n        );\n        const txFee = Math.ceil(satoshisPerByte * byteCount);\n        return txFee;\n    };\n\n    const sendToken = async (\n        BCH,\n        wallet,\n        slpBalancesAndUtxos,\n        { tokenId, amount, tokenReceiverAddress },\n    ) => {\n        // Handle error of user having no BCH\n        if (slpBalancesAndUtxos.nonSlpUtxos.length === 0) {\n            throw new Error(\n                `You need some ${currency.ticker} to send ${currency.tokenTicker}`,\n            );\n        }\n        const largestBchUtxo = slpBalancesAndUtxos.nonSlpUtxos.reduce(\n            (previous, current) =>\n                previous.value > current.value ? previous : current,\n        );\n\n        const bchECPair = BCH.ECPair.fromWIF(largestBchUtxo.wif);\n        const tokenUtxos = slpBalancesAndUtxos.slpUtxos.filter(\n            (utxo, index) => {\n                if (\n                    utxo && // UTXO is associated with a token.\n                    utxo.tokenId === tokenId && // UTXO matches the token ID.\n                    utxo.utxoType === 'token' // UTXO is not a minting baton.\n                ) {\n                    return true;\n                }\n                return false;\n            },\n        );\n\n        if (tokenUtxos.length === 0) {\n            throw new Error(\n                'No token UTXOs for the specified token could be found.',\n            );\n        }\n\n        // BEGIN transaction construction.\n\n        // instance of transaction builder\n        let transactionBuilder;\n        if (process.env.REACT_APP_NETWORK === 'mainnet') {\n            transactionBuilder = new BCH.TransactionBuilder();\n        } else transactionBuilder = new BCH.TransactionBuilder('testnet');\n\n        const originalAmount = largestBchUtxo.value;\n        transactionBuilder.addInput(\n            largestBchUtxo.tx_hash,\n            largestBchUtxo.tx_pos,\n        );\n\n        let finalTokenAmountSent = new BigNumber(0);\n        let tokenAmountBeingSentToAddress = new BigNumber(amount);\n\n        let tokenUtxosBeingSpent = [];\n        for (let i = 0; i < tokenUtxos.length; i++) {\n            finalTokenAmountSent = finalTokenAmountSent.plus(\n                new BigNumber(tokenUtxos[i].tokenQty),\n            );\n            transactionBuilder.addInput(\n                tokenUtxos[i].tx_hash,\n                tokenUtxos[i].tx_pos,\n            );\n            tokenUtxosBeingSpent.push(tokenUtxos[i]);\n            if (tokenAmountBeingSentToAddress.lte(finalTokenAmountSent)) {\n                break;\n            }\n        }\n\n        const slpSendObj = BCH.SLP.TokenType1.generateSendOpReturn(\n            tokenUtxosBeingSpent,\n            tokenAmountBeingSentToAddress.toString(),\n        );\n\n        const slpData = slpSendObj.script;\n\n        // Add OP_RETURN as first output.\n        transactionBuilder.addOutput(slpData, 0);\n\n        // Send dust transaction representing tokens being sent.\n        transactionBuilder.addOutput(\n            BCH.SLP.Address.toLegacyAddress(tokenReceiverAddress),\n            546,\n        );\n\n        // Return any token change back to the sender.\n        if (slpSendObj.outputs > 1) {\n            // Try to send this to Path1899 to move all utxos off legacy addresses\n            if (wallet.Path1899.legacyAddress) {\n                transactionBuilder.addOutput(\n                    wallet.Path1899.legacyAddress,\n                    546,\n                );\n            } else {\n                // If you can't, send it back from whence it came\n\n                transactionBuilder.addOutput(\n                    BCH.SLP.Address.toLegacyAddress(\n                        tokenUtxosBeingSpent[0].address,\n                    ),\n                    546,\n                );\n            }\n        }\n\n        // get byte count to calculate fee. paying 1 sat\n        // Note: This may not be totally accurate. Just guessing on the byteCount size.\n        const txFee = calcFee(\n            BCH,\n            tokenUtxosBeingSpent,\n            5,\n            1.1 * currency.defaultFee,\n        );\n\n        // amount to send back to the sending address. It's the original amount - 1 sat/byte for tx size\n        const remainder = originalAmount - txFee - 546 * 2;\n        if (remainder < 1) {\n            throw new Error('Selected UTXO does not have enough satoshis');\n        }\n\n        // Last output: send the BCH change back to the wallet.\n        // If Path1899, send it to Path1899 address\n        if (wallet.Path1899.legacyAddress) {\n            transactionBuilder.addOutput(\n                wallet.Path1899.legacyAddress,\n                remainder,\n            );\n        } else {\n            // Otherwise send it back from whence it came\n            transactionBuilder.addOutput(\n                BCH.Address.toLegacyAddress(largestBchUtxo.address),\n                remainder,\n            );\n        }\n\n        // Sign the transaction with the private key for the BCH UTXO paying the fees.\n        let redeemScript;\n        transactionBuilder.sign(\n            0,\n            bchECPair,\n            redeemScript,\n            transactionBuilder.hashTypes.SIGHASH_ALL,\n            originalAmount,\n        );\n\n        // Sign each token UTXO being consumed.\n        for (let i = 0; i < tokenUtxosBeingSpent.length; i++) {\n            const thisUtxo = tokenUtxosBeingSpent[i];\n            const accounts = [wallet.Path245, wallet.Path145, wallet.Path1899];\n            const utxoEcPair = BCH.ECPair.fromWIF(\n                accounts\n                    .filter(acc => acc.cashAddress === thisUtxo.address)\n                    .pop().fundingWif,\n            );\n\n            transactionBuilder.sign(\n                1 + i,\n                utxoEcPair,\n                redeemScript,\n                transactionBuilder.hashTypes.SIGHASH_ALL,\n                thisUtxo.value,\n            );\n        }\n\n        // build tx\n        const tx = transactionBuilder.build();\n\n        // output rawhex\n        const hex = tx.toHex();\n        // console.log(`Transaction raw hex: `, hex);\n\n        // END transaction construction.\n\n        const txidStr = await BCH.RawTransactions.sendRawTransaction([hex]);\n        if (txidStr && txidStr[0]) {\n            console.log(`${currency.tokenTicker} txid`, txidStr[0]);\n        }\n\n        let link;\n        if (process.env.REACT_APP_NETWORK === `mainnet`) {\n            link = `${currency.blockExplorerUrl}/tx/${txidStr}`;\n        } else {\n            link = `${currency.blockExplorerUrlTestnet}/tx/${txidStr}`;\n        }\n\n        //console.log(`link`, link);\n\n        return link;\n    };\n\n    const sendBch = async (\n        BCH,\n        wallet,\n        utxos,\n        { addresses, values, encodedOpReturn },\n        callbackTxId,\n    ) => {\n        // Note: callbackTxId is a callback function that accepts a txid as its only parameter\n\n        try {\n            if (!values || values.length === 0) {\n                return null;\n            }\n\n            const value = values.reduce(\n                (previous, current) => new BigNumber(current).plus(previous),\n                new BigNumber(0),\n            );\n            const REMAINDER_ADDR = wallet.Path1899.cashAddress;\n            const inputUtxos = [];\n            let transactionBuilder;\n\n            // instance of transaction builder\n            if (process.env.REACT_APP_NETWORK === `mainnet`)\n                transactionBuilder = new BCH.TransactionBuilder();\n            else transactionBuilder = new BCH.TransactionBuilder('testnet');\n\n            const satoshisToSend = BCH.BitcoinCash.toSatoshi(value.toFixed(8));\n            let originalAmount = new BigNumber(0);\n            let txFee = 0;\n            for (let i = 0; i < utxos.length; i++) {\n                const utxo = utxos[i];\n                originalAmount = originalAmount.plus(utxo.value);\n                const vout = utxo.vout;\n                const txid = utxo.txid;\n                // add input with txid and index of vout\n                transactionBuilder.addInput(txid, vout);\n\n                inputUtxos.push(utxo);\n                txFee = encodedOpReturn\n                    ? calcFee(BCH, inputUtxos, addresses.length + 2)\n                    : calcFee(BCH, inputUtxos, addresses.length + 1);\n\n                if (originalAmount.minus(satoshisToSend).minus(txFee).gte(0)) {\n                    break;\n                }\n            }\n\n            // amount to send back to the remainder address.\n            const remainder = Math.floor(\n                originalAmount.minus(satoshisToSend).minus(txFee),\n            );\n            if (remainder < 0) {\n                const error = new Error(`Insufficient funds`);\n                error.code = SEND_BCH_ERRORS.INSUFICIENT_FUNDS;\n                throw error;\n            }\n\n            if (encodedOpReturn) {\n                transactionBuilder.addOutput(encodedOpReturn, 0);\n            }\n\n            // add output w/ address and amount to send\n            for (let i = 0; i < addresses.length; i++) {\n                const address = addresses[i];\n                transactionBuilder.addOutput(\n                    BCH.Address.toCashAddress(address),\n                    BCH.BitcoinCash.toSatoshi(Number(values[i]).toFixed(8)),\n                );\n            }\n\n            if (remainder >= BCH.BitcoinCash.toSatoshi(DUST)) {\n                transactionBuilder.addOutput(REMAINDER_ADDR, remainder);\n            }\n\n            // Sign the transactions with the HD node.\n            for (let i = 0; i < inputUtxos.length; i++) {\n                const utxo = inputUtxos[i];\n                transactionBuilder.sign(\n                    i,\n                    BCH.ECPair.fromWIF(utxo.wif),\n                    undefined,\n                    transactionBuilder.hashTypes.SIGHASH_ALL,\n                    utxo.value,\n                );\n            }\n\n            // build tx\n            const tx = transactionBuilder.build();\n            // output rawhex\n            const hex = tx.toHex();\n\n            // Broadcast transaction to the network\n            const txidStr = await BCH.RawTransactions.sendRawTransaction([hex]);\n\n            if (txidStr && txidStr[0]) {\n                console.log(`${currency.ticker} txid`, txidStr[0]);\n            }\n            let link;\n\n            if (callbackTxId) {\n                callbackTxId(txidStr);\n            }\n            if (process.env.REACT_APP_NETWORK === `mainnet`) {\n                link = `${currency.blockExplorerUrl}/tx/${txidStr}`;\n            } else {\n                link = `${currency.blockExplorerUrlTestnet}/tx/${txidStr}`;\n            }\n            //console.log(`link`, link);\n\n            return link;\n        } catch (err) {\n            if (err.error === 'insufficient priority (code 66)') {\n                err.code = SEND_BCH_ERRORS.INSUFFICIENT_PRIORITY;\n            } else if (err.error === 'txn-mempool-conflict (code 18)') {\n                err.code = SEND_BCH_ERRORS.DOUBLE_SPENDING;\n            } else if (err.error === 'Network Error') {\n                err.code = SEND_BCH_ERRORS.NETWORK_ERROR;\n            } else if (\n                err.error ===\n                'too-long-mempool-chain, too many unconfirmed ancestors [limit: 25] (code 64)'\n            ) {\n                err.code = SEND_BCH_ERRORS.MAX_UNCONFIRMED_TXS;\n            }\n            console.log(`error: `, err);\n            throw err;\n        }\n    };\n\n    const getBCH = (apiIndex = 0) => {\n        let ConstructedSlpWallet;\n\n        ConstructedSlpWallet = new SlpWallet('', {\n            restURL: getRestUrl(apiIndex),\n        });\n        return ConstructedSlpWallet.bchjs;\n    };\n\n    return {\n        getBCH,\n        calcFee,\n        getUtxos,\n        getHydratedUtxoDetails,\n        getSlpBalancesAndUtxos,\n        getTxHistory,\n        getRestUrl,\n        sendBch,\n        sendToken,\n    };\n}\n"]},"metadata":{},"sourceType":"module"}